0001   0000             ; 	SIMPL is a tiny Forth-like stack based language used to exercise the Suite_16 instruction set
0002   0000             ; 	and provide useful programming debugging facilities; 
0003   0000             
0004   0000             ; 	SIMPL_Suite16_2020_4.asm
0005   0000             
0006   0000             ; 	Ken Boak January 2020 
0007   0000             
0008   0000             ; 	To assemble: use tasm -s -h -c -g0 -t16 SIMPL_Suite16_2020_4.asm out.hex
0009   0000             
0010   0000             ; 	This code contains the framework routines and main utility routines for SIMPL coded for the Suite-16
0011   0000             ;
0012   0000             
0013   0000             ;	Framework Routines
0014   0000             
0015   0000             ;	Text_Read   Get a character from the UART and store it in the text buffer
0016   0000             ;	Text_Check  Examine the character to determine it is a number, an alpha, a symbol, a colon or terminator  
0017   0000             ;   Number      If numerical ascii characters are found - form a 16-bit integer and put it on the stack
0018   0000             ;   Jump_Table  Look up the code address associated with the character and jump to it.
0019   0000             ;   Execute     Run the action routine associated with the character - then jump back to NEXT
0020   0000             ;   NEXT        Fetch the next character from the instruction buffer
0021   0000             ;
0022   0000             ;	Utility Routines
0023   0000             ;
0024   0000             ; 	Get_Number  Read the text buffer for decimal characters and form a 16-bit integer
0025   0000             ; 	Print_Num   Print a 5 digit decimal number from a 16-bit integer
0026   0000             ; 	Get_Hex     Read the text buffer for hexidecimal characters and form a 16-bit integer
0027   0000             ; 	Print_Hex   Print a 4 digit hexadecimal number from a 16-bit integer
0028   0000             ; 	HexDump		Display a block of memory in the usual hex dup fashion
0029   0000             
0030   0000             ; 	To assemble: use tasm -s -h -c -g0 -t16 SIMPL_Suite16_2020_4.asm out.hex
0031   0000             
0032   0000             ;-------------------------------------------------------------------------------
0033   0000             ; SIMPL - a very small Forth Inspired, Extensible Language
0034   0000             ; Implementing the Initialisation, TextTead, TextEval and UART routines in Suite_16 assembly language
0035   0000             ;
0036   0000             ; A Forth-Like Language in under 1024 bytes
0037   0000             
0038   0000             ; Memory Map - initial implementation
0039   0000             
0040   0000             ; $0000   Start
0041   0000             ; $0000   Interpreter framework: Text_Read, number, next
0042   0000             ; $004D   Utility Print_Num
0043   0000             ; $0074	  Utility getchar
0044   0000             ; $007C   Utility Get_Hex
0045   0000             ; $009D   Utility Print_Hex
0046   0000             ; $00C5	  Utility Hex_Dump
0047   0000             ; $00F0   Utility Arithmetic & Logic
0048   0000             ; $0100   Jump Table		$60 words	
0049   0000             ; $0160   Free space		$A0 words		
0050   0000             ; $0200   Input Buffer     	$20 words
0051   0000             ; $0220	  Action Routines	$200 words
0052   0000             ; $0420   User Words        $360 words
0053   0000             ; $0780   RAM (stacks etc)	$80 words
0054   0000             ; $07FF	  Top of RAM
0055   0000              
0056   0000             ; Ken Boak   January 2020
0057   0000             
0058   0000             ; TO DO
0059   0000             
0060   0000             ; Loops, I/O, Strings and Delays  to be added
0061   0000             
0062   0000             ; This version 860 bytes    921600 baud serial communications
0063   0000             
0064   0000             ; Input and output to UART Port P2 of Nucleo STM32H743 added with "i" and "o" commands
0065   0000             
0066   0000             ; Include Hex_Loader into memory map
0067   0000             
0068   0000             ;-------------------------------------------------------------------------------
0069   0000             
0070   0000             ; Primitive Instructions
0071   0000             
0072   0000             ; These allow basic maths an logical instructions on 16-bit integers     +  -  /  *  &  |   ^   ~
0073   0000             ; Stack Manipulation   DUP DROP PUSH POP SWAP OVER
0074   0000             ; Memory transfers with FETCH and STORE
0075   0000             ; Compilation mode with : and ;
0076   0000             ; Simple decrementing loops   (..........)
0077   0000             ; Input and Output
0078   0000             ; Print a string _Hello World_
0079   0000             
0080   0000             ; Note as of 21-01-2020 - not all of these are fully implemented
0081   0000             
0082   0000             ;   Primitives based on ascii symbols:
0083   0000             
0084   0000             ;	ADD       +
0085   0000             ;	SUB       -
0086   0000             ;	SHR       /    shift right  (divide by 2)
0087   0000             ;	SHL       *    shift left   (multiply by 2)
0088   0000             ;	AND       &
0089   0000             ;	OR        |
0090   0000             ;	XOR       ^
0091   0000             ;	INV       ~
0092   0000             ;	DUP       “    Duplicate the top member of the stack
0093   0000             ;	DROP      `    Drop the top member of the stack
0094   0000             ;	PUSH      ,
0095   0000             ;	POP       ‘
0096   0000             ;	SWAP      $    Swap the top and 2nd members of the stack
0097   0000             ;	OVER      %
0098   0000             ;	FETCH     @
0099   0000             ;	STORE     !
0100   0000             ;	CALL      :
0101   0000             ;	RETURN    ;
0102   0000             ;	JMP       \
0103   0000             ;	JE        =    Jump if top = 0
0104   0000             ;	JGT       >    Jump if top > 0 
0105   0000             ;	JLT       <    Jump if top < 0
0106   0000             ;	TO-R      {    Copy top to return stack
0107   0000             ;	FROM-R    }    Copy return stack to top
0108   0000             ;	LOOP-Strt (    
0109   0000             ;	LOOP-End  )
0110   0000             ;	IN        [    Get a byte from the port addressed by top
0111   0000             ;	OUT       ]    Send a byte from 2nd to the port addressed by top
0112   0000             ;	KEY       ?    Get a character from serial port
0113   0000             ;	PRINT     _    _Print the text string enclosed between the underscores_
0114   0000             ;	NOP       Space
0115   0000             ;   LIT       #	   Put the following literal into top
0116   0000             
0117   0000             ;-------------------------------------------------------------------------------
0118   0000             
0119   0000             ;	Lower case letters are used to execute more complex built in routines:
0120   0000             
0121   0000             ;	a
0122   0000             ;	b		fetch a block of code via serial port
0123   0000             ;	c
0124   0000             ;	d		dump a block of code
0125   0000             ;	e		execute code at a given block address
0126   0000             ;	f
0127   0000             ;	g
0128   0000             ;	h       set port pin high
0129   0000             ;	i       input byte from port
0130   0000             ;	j
0131   0000             ;	k       access the loop counter variable
0132   0000             ;	l       set port pin low
0133   0000             ;	m       milliseconds delay
0134   0000             ;	n
0135   0000             ;	o       output byte to port
0136   0000             ;	p       print the top of stack to terminal as a 16-bit integer
0137   0000             ;	q       print the ascii character at given RAM location
0138   0000             ;	r       read input pin
0139   0000             ;	s       sample the ADC
0140   0000             ;	t
0141   0000             ;	u       microseconds delay
0142   0000             ;	v		define a variable
0143   0000             ;	w
0144   0000             ;	x
0145   0000             ;	y
0146   0000             ;	z
0147   0000             
0148   0000             ; ---------------------------------------User Defined Words----------------------------------------
0149   0000             
0150   0000             ;		Upper case letters A to Z are used to define 26, User "Words"
0151   0000             
0152   0000             ;       They are allocated fixed addresses at $20 word intervals, starting at $0420.  A = $0420, Z = $0760
0153   0000             ;       
0154   0000             
0155   0000             ;		User Routines are defined by capital letters starting  with colon : and end with semicolon ;
0156   0000             
0157   0000             ;		eg  :F10(100mh200ml);		;	Flash the led 10 times - high for 100mS and low for 200mS
0158   0000             
0159   0000             ;		You can play sequences of notes (tunes) through a small speaker  ABC etc
0160   0000             ; 		Some common notes are defined as follows
0161   0000             
0162   0000             ;		:A40{h1106ul1106u);			 musical note A
0163   0000             ;		:B5{h986ul986u);			 musical note B
0164   0000             ;       :C51{h929ul929u);			 musical note C
0165   0000             ;       :D57{h825ul825u);			 musical note D
0166   0000             ;       :E64{h733ul733u);			 musical note E
0167   0000             ;       :F72{h690ul691u);			 musical note F
0168   0000             ;       :G81{h613ul613u);			 musical note G
0169   0000             
0170   0000             ;       :H_Hello World, and welcome to SIMPL_;   A Banner Message
0171   0000             
0172   0000             ; The following 26 commands are normally available to users - shown here with starting address
0173   0000             
0174   0000             ;	A			$0420
0175   0000             ;	B			$0440			
0176   0000             ;	C			$0460
0177   0000             ;	D			$0480
0178   0000             ;	E			$04A0
0179   0000             ;	F			$04C0
0180   0000             ;	G			$04E0
0181   0000             ;	H			$0500
0182   0000             ;	I			$0520
0183   0000             ;	J			$0540
0184   0000             ;	K			$0560
0185   0000             ;	L			$0580
0186   0000             ;	M			$05A0
0187   0000             ;	N			$05C0
0188   0000             ;	O			$05E0
0189   0000             ;	P			$0600
0190   0000             ;	Q			$0620
0191   0000             ;	R			$0640
0192   0000             ;	S			$0660
0193   0000             ;	T			$0680
0194   0000             ;	U			$06A0
0195   0000             ;	V			$06C0
0196   0000             ;	W			$0700
0197   0000             ;	X			$0720
0198   0000             ;	Y			$0740
0199   0000             ;	Z			$0760			
0200   0000             
0201   0000             ;-------------------------------------------------------------------------------
0202   0000             
0203   0000             ;   Examples of SIMPL phrases
0204   0000             
0205   0000             ; 	eg add 123 and 456 and print the result to the terminal
0206   0000             
0207   0000             ; 	123 456+p
0208   0000             
0209   0000             ;	Loop 10 times printing "Spurs are Fab!"
0210   0000             
0211   0000             ; 	10(_Spurs are Fab!_)
0212   0000             
0213   0000             ;   Flash a LED 10 times 100mS on 200mS off
0214   0000             
0215   0000             ;   10(h100ml200m)
0216   0000             
0217   0000             
0218   0000             ;   Toggle a port pin at 1MHz   1000(hlhlhlhlhlhlhlhlhlhl)
0219   0000             
0220   0000             ;-------------------------------------------------------------------------------
0221   0000             
0222   0000             
0223   0000             
0224   0000             ;   SIMPL is basically a character interpreter based on a switch statement contained within a loop
0225   0000             
0226   0000             ; 	In assembly language the switch statement is usually best implemented as a jump table.
0227   0000             ;   An Instruction Pointer IP, selects the next instruction from an array of characters in RAM
0228   0000             ;   Unlike Forth that uses words stored in a dictionary, SIMPL uses single printable ascii characters
0229   0000             ;   These characters are chosen to either be familiar symbols (+ -  * / etc) or have a high mnemonic value
0230   0000             ;   The ascii character command is used as an index into the jump table
0231   0000             ; 	The jump table contains the starting addresses of all the primitive commands and routines.
0232   0000             ;   After indexing into the table, the interpreter jumps to the address it finds and then executes code
0233   0000             ;   starting from that address.
0234   0000             ; 	At the end of the code block, the interpreter jumps back to NEXT, to fetch the next command.
0235   0000             
0236   0000             
0237   0000             
0238   0000             ; Register Usage and constants
0239   0000             
0240   0000             ;-------------------------------------------------------------------------------
0241   0000             ; CPU registers - yet to be fully defined for Suite_16
0242   0000             
0243   0000             ; Register Usage
0244   0000             
0245   0000             ;	tos: 			.EQU R0			; top of stack
0246   0000             ;	sos:			.EQU R1			; second on stack
0247   0000             ;	temp2:			.EQU R2
0248   0000             ;	temp3:			.EQU R3
0249   0000             ;	temp4:			.EQU R4
0250   0000             ;	stack: 			.EQU R5
0251   0000             ;	scratch6:		.EQU R6
0252   0000             ;	temp7: 			.EQU R7			; loop start
0253   0000             ;	ip: 			.EQU R8			; instruction pointer
0254   0000             ;	temp9: 			.EQU R9			; millisecond delay
0255   0000             ;	temp10: 		.EQU R10        ; microsecond delay
0256   0000             ;	temp11:			.EQU R11		; scratch
0257   0000             ;	instr: 			.EQU R12		; instruction fetched into R12 for decoding
0258   0000             ;	temp13:			.EQU R13		; arithmetic / scratch
0259   0000             ;	temp14: 		.EQU R14		; used for buffer pointer
0260   0000             ;	RSP: 			.EQU R15	    ; Return from alpha  next IP
0261   0000             
0262   0000             
0263   0000             EOS:         	.EQU $0000      ; End of string
0264   0000             
0265   0000             ;-------------------------------------------------------------------------------
0266   0000             
0267   0000             ;   The core of the SIMPL interpreter is coded as these short routines:
0268   0000             
0269   0000             ;	Text_Read   Get a character from the UART and store it in the text buffer
0270   0000             ;	Text_Check  Examine the character to determine it is a number, an alpha, a symbol, a colon or terminator  
0271   0000             ;   Number      If numerical ascii characters are found - form a 16-bit integer and put it on the stack
0272   0000             ;   Jump_Table  Look up the code address associated with the character and jump to it.
0273   0000             ;   Execute     Run the action routine associated with the character - then jump back to NEXT
0274   0000             ;   NEXT        Fetch the next character from the instruction buffer
0275   0000             
0276   0000             ;	SIMPL has an immediate mode - where a phrase of commands typed at the keyboard will be executed
0277   0000             ;	immediately after the return key is pressed.
0278   0000             
0279   0000             ;	It also has a "colon definition" mode - If the first character in the text buffer is a colon it
0280   0000             ;   will define a new word - based on the uppercase ALPHA character that immediately follows the colon.
0281   0000             ;   This new definition will be stored in RAM at a fixed address calculated from the value of the ascii
0282   0000             ;   character.
0283   0000              
0284   0000             ;	32 bytes of storage is allocated in RAM for each ALPHA character.
0285   0000             ;   This limitation means that definitions are kept short, concise, and can be chained together to form
0286   0000             ; 	larger program constructs.
0287   0000             
0288   0000             
0289   0000             
0290   0000             ;------------------------------------------------------------------------------------------------
0291   0000             ; We now come to decoding the characters - where based on the value of the character 
0292   0000             ; we perform some action routine
0293   0000             ; But first we need to determine whether the characers form part of a number
0294   0000             ; these must be decoded separately and put on the stack - using the "number" routine
0295   0000             ;------------------------------------------------------------------------------------------------
0296   0000             
0297   0000             ; ip  - R8 instruction pointer to the current character in the input buffer
0298   0000             ;----------------------------------------------------------------------------------------------------------
0299   0000             ; The character is either a primitive or an alpha - so form CALL address
0300   0000             ; Restore R8 to start of RAM buffer
0301   0000             ; Get the current character location
0302   0000             ; If it's a primitive symbol or lowercase alpha between 0x20 and 0x2F or >$39 - point to a look-up table and fetch it's code segment address
0303   0000             ; If it's a numeral between ascii $30 and $39 jump to the number routine to process the digit
0304   0000             ; If its an ALPHA user word - it will execute from a fixed address stored in the jump table
0305   0000             
0306   0000             ; next fetches the next ascii character instruction from memory, decodes it into a jump address
0307   0000             ; and executes the code found at that code address
0308   0000             ; Each executed word jumps back to next
0309   0000             ; Numbers are treated differenty - they are enummerated and put onto the stack by the number routine
0310   0000             
0311   0000             ; Now we need to decode the instructions using a jump table
0312   0000             ; Numbers have their own separate decode routine: "number"
0313   0000             
0314   0000             ;----------------------------------------------------------------------------------------------------------
0315   0000             
0316   0000             .org $0000
0317   0000             start:
0318   0000             
0319   0000             ;--------------------------------------Text_Read-----------------------------------------------------------
0320   0000             ; Text_Read - This implements the SIMPL interpreter in Suite_16 assembly Language
0321   0000             ;----------------------------------------------------------------------------------------------------------
0322   0000             
0323   0000             ; Get a character from the UART and store it in the input buffer starting at 0x0200
0324   0000             
0325   0000             ; Supports immediate mode - where characters are stored at 0x200 and executed directly
0326   0000             ; Supports compiled mode - where string starts with a colon and the next character "NAME" is an upper case alpha
0327   0000             ; String is stored at 0x200 plus a multiple of 32 byte offset according to the value of "NAME"
0328   0000             
0329   0000             ; Register Usage 
0330   0000             
0331   0000             ;  The input buffer - starts at $0200
0332   0000             ;  R0 receives the next character from the text buffer pointed to by R8
0333   0000             ;  Test it against CR, NL, unprintable characters and colon
0334   0000             ;  If it starts with a colon - get the next character (the NAME) and store at a specific location in memory
0335   0000             ;  If it does not start with a colon, interpret and execute each character in turn
0336   0000             
0337   0000             ;----------------------------------------------------------------------------------------------------------
0338   0000             
0339   0000             Text_Read:
0340   0000             
0341   0000 00 74           BRA getchar             ; Get the input buffer from the UART
0342   0001             	
0343   0001 18 00 02 00 	SET R8, 512			    ; R8 points to char buffer
0344   0003             		
0345   0003             Text_Check:
0346   0003             
0347   0003 E8 00           INC R8					; Get the next character from the buffer
0348   0004             	
0349   0004 48 00       	LD  R0, @R8				; Get it's ascii value into the accumulator
0350   0005             	
0351   0005 34 00       	ST  R4, R0			    ; Temporary store in R4
0352   0006             	
0353   0006 0B 0D       	SBI $0D					; Is it a carriage return?
0354   0007 06 25       	BEQ textEnd
0355   0008 24 00       	LD  R0,R4
0356   0009 0B 0A       	SBI $0A					; Is it a newline?
0357   000A 06 25       	BEQ textEnd
0358   000B 24 00       	LD  R0,R4
0359   000C 0B 20       	SBI $20					; Is it unprintable - Too low?
0360   000D 04 24       	BLE nonValid
0361   000E 24 00       	LD  R0,R4
0362   000F 0B 7F       	SBI $7F					; Is it unprintable - Too High?
0363   0010 03 24       	BGE nonValid
0364   0011 24 00       	LD  R0,R4
0365   0012 0B 3E       	SBI $3E					; Is it a colon?
0366   0013 05 21       	BNE notColon
0367   0014             	
0368   0014             Colon:						; If the input character is a colon
0369   0014             
0370   0014 08 00 00 74 	CALL    getchar    	    ; get the next character - which is the NAME
0371   0016 0B 50       	SBI     $50				; subtract ascii "A" - $11 from R0 - puts it on $20 boundaries starting	at $220
0372   0017 A0 00       	ADD		R0				; x2
0373   0018 A0 00       	ADD		R0				; x4
0374   0019 A0 00       	ADD		R0				; x8
0375   001A A0 00       	ADD     R0				; x16
0376   001B A0 00       	ADD		R0				; x32
0377   001C             	
0378   001C A8 00       	ADD		R8				; Add to the instruction pointer R8
0379   001D 32 00       	ST		R2, R0			; Temporary store this buffer address in R2
0380   001E 24 00       	LD		R0, R4			; Get the character back
0381   001F 52 00       	ST      @R2, R0			; Store it in the correct place in correct definition buffer
0382   0020             	
0383   0020 00 24       	BRA		nonValid		; move on to next step
0384   0021             
0385   0021             notColon:		
0386   0021 E8 00       	INC   R8                ; Increment buffer pointer R8
0387   0022 24 00       	LD	  R0, R4			; Get the character back
0388   0023 58 00       	ST    @R8, R0			; Store character in RAM buffer indexed by R8
0389   0024             
0390   0024             nonValid:
0391   0024             
0392   0024 00 74       	BRA   getchar
0393   0025             	
0394   0025             textEnd:		
0395   0025             
0396   0025 10 00 00 80 	SET R0, $80
0397   0027 58 00       	ST	@R8, R0				; Put a null terminating (0x80) zero on the end of the buffer
0398   0028 18 00 02 00 	SET R8, $0200			; set ip (instruction pointer) - to start of input buffer in RAM at address 0x0200
0399   002A 00 47       	BRA	    NEXT			; get the next instruction
0400   002B             
0401   002B             ; Text_Read  43 Instruction words
0402   002B             	
0403   002B             ;---------------------------------------------Number--------------------------------------------------------	
0404   002B             	
0405   002B             	
0406   002B             number:						; Accept up to 5 decimal digits from serial and put into memory as 16-bit integer
0407   002B             
0408   002B 17 00 00 00 	SET R7, 0		    	; Clear R7	
0409   002D 18 00 02 00 	SET R8, 512			    ; R8 points to char buffer
0410   002F             	
0411   002F             number1:	
0412   002F             	
0413   002F 48 00       	LD R0, @R8				; Get the first character	
0414   0030 34 00       	ST R4, R0				; Temporary store in R4
0415   0031             	
0416   0031 E8 00       	INC R8					; Point to next character	
0417   0032 48 00       	LD R0, @R8				; Get the next character
0418   0033             	
0419   0033 0B 30       	SBI  $30				; Is it bigger than $30 ?	
0420   0034 02 42       	BLT endNumber
0421   0035             	
0422   0035 0B 0A       	SBI $0A					; Is it less than $10	
0423   0036 03 42       	BGE endNumber
0424   0037             	
0425   0037 24 00       	LD R0, R4				; Get original character back
0426   0038 0B 30       	SBI  $30				; Form an ascii digit
0427   0039             	
0428   0039 A7 00       	ADD R7					; Add in accumulating total from R7
0429   003A             	
0430   003A             times10:	
0431   003A             	
0432   003A 35 00       	ST R5,R0				; Digit is now in R5	
0433   003B A5 00       	ADD R5					; R0 = 2 Times R0 
0434   003C A0 00       	ADD R0					; 4X
0435   003D A0 00       	ADD R0					; 8X
0436   003E A5 00       	ADD R5					; 9X
0437   003F A5 00       	ADD R5					; 10X
0438   0040             	
0439   0040 37 00       	ST R7, R0				; R7 is accumulation of all the digits multiplied by powers of 10
0440   0041             	
0441   0041 00 2F       	BRA number1				; go around and process the remaining digits
0442   0042             	
0443   0042             endNumber:
0444   0042             
0445   0042 24 00       	LD R0, R4				; Get the last digit back	
0446   0043 A7 00       	ADD R7					; Add in the accumulated sum
0447   0044 32 00       	ST  R2,R0				; Temporary store integer number in scratch reg R2
0448   0045             	
0449   0045 17 00 00 00 	SET R7,0				; Don't forget to clear R7
0450   0047             	
0451   0047             ; number  28 Instruction words	
0452   0047             
0453   0047             ;---------------------------------------------Next------------------------------------------------------------
0454   0047             ; Next fetches the next instruction and decides what to do with it
0455   0047             ; The character is either a primitive or an ALPHA - so index into jump table to get the execution address 
0456   0047             ; Restore R to start of RAM buffer
0457   0047             
0458   0047             NEXT:
0459   0047             
0460   0047 E8 00       	INC R8					; Point to the next character
0461   0048 48 00       	LD R0, @R8				; Get the next character into R0
0462   0049 0A E0       	ADI $E0					; Add $E0 to form an address in the jump table range of $100 to $15F
0463   004A 33 00       	ST R3,R0				; Temporary store to R3
0464   004B             	
0465   004B 43 00       	LD R0, @R3				; Index into jump table	
0466   004C 00 E0       	.WORD $E000             ; JMP @ R0 Jump to the command routine (if its a ascii numeral - jump to number routine)
0467   004D             
0468   004D             ; next 6 Instruction words	
0469   004D             	
0470   004D             ;-----------------------------------------Print_Num---------------------------------------------
0471   004D             
0472   004D             ; Print_Num  Take the 16 bit value in top of stack register and prints it to terminal as an integer
0473   004D             ; Method -  repeated subtraction of powers of 10
0474   004D             
0475   004D             Print_Num:
0476   004D             
0477   004D                 ;  Prints out the value of R0 as a 5 digit decimal number to the terminal
0478   004D                 ;  Leading zeroes are not suppressed
0479   004D                 ;  R1 = Decimation Value
0480   004D                 ;  R2 = current digit 
0481   004D                 ;  R4 = temporary storage for accumulator (decimated value)
0482   004D             	;  R13 = $0D  Carriage Return
0483   004D             	
0484   004D             
0485   004D 12 00 00 00 	SET R2, 0
0486   004F             	
0487   004F 1D 00 00 0D 	SET R13, $0D			; Preload with carriage return char
0488   0051             	
0489   0051 11 00 27 10 	SET R1, 10000
0490   0053 08 00 00 67 	CALL decimate
0491   0055             	
0492   0055 11 00 03 E8 	SET R1, 1000
0493   0057 08 00 00 67 	CALL decimate
0494   0059             	
0495   0059 11 00 00 64 	SET R1, 100
0496   005B 08 00 00 67 	CALL decimate
0497   005D             	
0498   005D 11 00 00 0A 	SET R1, 10
0499   005F 08 00 00 67 	CALL decimate
0500   0061             	
0501   0061 0A 30       	ADI $30					; make the value an ascii numeral
0502   0062 0C 00       	OUT						; print to terminal
0503   0063 B4 00       	SUB R4
0504   0064             	
0505   0064 08 00 00 EB 	CALL CRLF				; Output a CRLF
0506   0066             	
0507   0066 00 47       	BRA NEXT
0508   0067             		
0509   0067             decimate:
0510   0067             
0511   0067 B1 00       	SUB R1					; subtract the power of 10 until R0 goes negative
0512   0068 02 6B           BLT value
0513   0069 E2 00           INC R2					; keep a count of how many times you subtract the decimation factor
0514   006A 00 67           BRA decimate	
0515   006B             	
0516   006B             value:
0517   006B             
0518   006B 34 00       	ST R4, R0
0519   006C 22 00       	LD R0, R2
0520   006D 0A 30       	ADI $30				    ; Add 0x30 to make R0 a printable digit
0521   006E 0C 00       	OUT						; print a digit
0522   006F             	
0523   006F 24 00       	LD R0, R4
0524   0070 A1 00       	ADD R1
0525   0071 12 00 00 00 	SET R2, 0				; reset R2
0526   0073             	
0527   0073 09 00       	RET
0528   0074             	
0529   0074             ; Print_Num   39 instruction words	
0530   0074             	
0531   0074             	
0532   0074             ;------------------------------------------------getchar-----------------------------------------------
0533   0074             ; 	
0534   0074             getchar:	
0535   0074             	
0536   0074             
0537   0074 0D 00       	IN						; Get character
0538   0075             	
0539   0075 11 00 02 00 	SET R1, 512			    ; R1 points to char buffer
0540   0077             	
0541   0077             loop1:	
0542   0077 41 00       	LD R0, @R1				; get first character
0543   0078 0C 00       	OUT                     ; output character
0544   0079 E1 00       	INC R1
0545   007A 01 77       	BGT loop1				; get characters until you find an EOS
0546   007B 00 03       	BRA Text_Check		    ; Back to Text_Check when you get an EOS
0547   007C             	
0548   007C             	; getchar  8 instructions 
0549   007C             	
0550   007C             ;-----------------------------------------Get_Hex---------------------------------------------
0551   007C             	
0552   007C             Get_Hex:
0553   007C             
0554   007C             	; Accepts a hexadecimal number up to FFFF from terminal input buffer
0555   007C             	; converts it to an integer and puts it into register R0
0556   007C             	; It can then be printed out as a decimal using Print_Num - for checking integrity
0557   007C             	; R1 is the pointer in the text buffer - which starts at 0x0200
0558   007C             	; R4 is used as a temporary store for the character in the accumulator R0
0559   007C             	; R5 is used in the "Times 16" routine
0560   007C             	; R7 is used to accumulate the powers of 16 when forming the integer in R0
0561   007C             	
0562   007C 11 00 02 00 	SET R1, 512				; R1 is start of text buffer
0563   007E 17 00 00 00 	SET R7, 0				; Clear R7
0564   0080             
0565   0080             nextchar:
0566   0080             
0567   0080 41 00       	LD R0, @R1				; get the first character
0568   0081 34 00       	ST R4, R0				; temporary store
0569   0082 E1 00       	INC R1
0570   0083 41 00       	LD R0, @R1				; get the next character to see if it is numeric or terminator
0571   0084             	
0572   0084 0B 30       	SBI $30					; Is it bigger than 0x30?
0573   0085 02 91       	BLT quit
0574   0086 0B 17       	SBI 23					; Is is bigger than ascii 'F'
0575   0087 03 91       	BGE quit
0576   0088             	
0577   0088 08 00 00 95 	CALL modify
0578   008A             	
0579   008A A7 00       	ADD R7
0580   008B A0 00       	ADD R0					; 2X
0581   008C A0 00       	ADD R0					; 4X
0582   008D A0 00       	ADD R0					; 8X
0583   008E A0 00       	ADD R0					; 16X
0584   008F             	
0585   008F 37 00       	ST  R7, R0				; R7 is the accumulating sum
0586   0090             	
0587   0090 00 80       	BRA nextchar
0588   0091             	
0589   0091             quit:	
0590   0091 08 00 00 95 	CALL modify
0591   0093             	
0592   0093 A7 00       	ADD R7					; Add in the final digit
0593   0094 00 4D       	BRA Print_Num			; Print it out in decimal
0594   0095             	
0595   0095             modify:
0596   0095             
0597   0095             	; If R0 = 0-9 subtract 0x30 to form a number 0-9
0598   0095             	; If R0 = A-F subtract 0x37 to form a number 10-15
0599   0095             	
0600   0095 24 00       	LD R0, R4				; Get R0 back from R4
0601   0096 0B 40       	SBI  $40					; Is it bigger than 0x40?
0602   0097 02 9A       	BLT  decimal			; must be a decimal 0-9
0603   0098 0A 09       	ADI  9                  ; Add 9 to turn R0 into 10 -15
0604   0099 00 9C       	BRA endmodify
0605   009A             	
0606   009A             decimal: 
0607   009A             
0608   009A 24 00       	LD R0, R4				; Get R0 back from R4
0609   009B 0B 30       	SBI $30				    ; convert to a decimal number
0610   009C             	
0611   009C             endmodify:
0612   009C             
0613   009C 09 00       	RET
0614   009D             
0615   009D             
0616   009D             ; Get_Hex   33 instructions
0617   009D             	
0618   009D             	
0619   009D             ;------------------------------------Print_Hex------------------------------------
0620   009D             
0621   009D             ;  Prints out a 4 digit hexadecimal number to the terminal according to contents of R0
0622   009D             ;  Leading zeroes are not suppressed
0623   009D             ;  R1 = Heximation Value
0624   009D             ;  R2 = digit count
0625   009D             ;  R4 = temporary storage for accumulator (decimated value)
0626   009D             ;  R6 = temporary store for output character
0627   009D             
0628   009D             ; This is based on the Print_Num routine with modifications to handle A-F characters
0629   009D             
0630   009D             Print_Hex:
0631   009D             
0632   009D 12 00 00 00 		SET R2,   0
0633   009F             				
0634   009F 11 00 10 00 		SET R1,   4096
0635   00A1 08 00 00 AE 		CALL   heximate
0636   00A3             		
0637   00A3 11 00 01 00 		SET R1,   256
0638   00A5 08 00 00 AE 		CALL   heximate
0639   00A7             		
0640   00A7 11 00 00 10 		SET R1,   16
0641   00A9 08 00 00 AE 		CALL   heximate
0642   00AB             		
0643   00AB 08 00 00 BB 		CALL printmod		; look at number and print correct character
0644   00AD             		
0645   00AD             		
0646   00AD 09 00       retn:	RET		
0647   00AE             		
0648   00AE             heximate:
0649   00AE             
0650   00AE B1 00       		SUB R1				; Subtract the power of 16
0651   00AF 02 B2       		BLT tempstore		; If it goes negative the decimation is finished
0652   00B0 E2 00       		INC R2				; Increment the decimation count
0653   00B1 00 AE       		BRA heximate		; repeat until negative
0654   00B2             		
0655   00B2             tempstore:
0656   00B2             
0657   00B2 34 00       		ST R4, R0			; temporarily store the remainder
0658   00B3 22 00       		LD R0, R2			; get the decimation count from R2
0659   00B4 08 00 00 BB 		CALL printmod       ; look at number and print correct character
0660   00B6             		
0661   00B6 24 00       		LD R0, R4			; get remainder back
0662   00B7 A1 00       		ADD R1				; adds the R1 value to restore sum
0663   00B8 12 00 00 00 		SET R2, 0			; Clear the count
0664   00BA 09 00       		RET
0665   00BB             		
0666   00BB             printmod:					; look at number and print correct character
0667   00BB 0A 30       		ADI $30				; ADD 0x30 to make it a number
0668   00BC 36 00       		ST R6, R0			; Temporary store to R6		
0669   00BD 0B 3A       		SBI $3A				; is it bigger than ascii '9'
0670   00BE 02 C2       		BLT printdec		; output as decimal digit
0671   00BF 0A 41       		ADI $41				; otherwise make it a hex digit
0672   00C0 0C 00       		OUT	
0673   00C1 00 C4       		BRA restore
0674   00C2             		
0675   00C2             printdec:		
0676   00C2 26 00       		LD R0, R6
0677   00C3 0C 00       		OUT
0678   00C4             		
0679   00C4             restore:
0680   00C4 09 00       		RET
0681   00C5             		
0682   00C5             		
0683   00C5             ;		Print_Hex  40 instructions	
0684   00C5             	
0685   00C5             ; ---------------------------HEXDUMP------------------------------------------ 
0686   00C5             
0687   00C5             ; Dump a page of memory to the screen
0688   00C5             ; Address on LHS, followed by 16 words across the screen need about 90 characters wide
0689   00C5             ; Print out 256 words over 16 lines
0690   00C5             
0691   00C5             ; R0 = value to be printed
0692   00C5             ; R11 = pointer to memory starting at 0x0000
0693   00C5             ; R13 = 0x0D Carriage Return
0694   00C5             
0695   00C5 1D 00 00 0D 	SET R13, $0D		; Preload with carriage return char
0696   00C7 19 00 01 00 	SET R9,  $100		; 256 words to dump
0697   00C9 1A 00 00 0A 	SET R10, $0A		; 16 words to a line
0698   00CB 1B 00 00 00 	SET R11, 0			; Begin dump from address 0
0699   00CD             	
0700   00CD             
0701   00CD             nextaddress:	
0702   00CD             	
0703   00CD             	
0704   00CD 2B 00       	LD R0, R11			; Get the address
0705   00CE 08 00 00 9D 	CALL Print_Hex		; print the address
0706   00D0 10 00 00 3E 	SET R0, $3E			; > Cursor
0707   00D2 0C 00       	OUT
0708   00D3 0B 1E       	SBI $1E			; 3E - $1E  = $20  two spaces
0709   00D4 0C 00       	OUT
0710   00D5 0C 00       	OUT
0711   00D6             	
0712   00D6             nextword:
0713   00D6             
0714   00D6 4B 00       	LD R0, @R11			; get the next word from memory
0715   00D7 08 00 00 9D 	CALL Print_Hex		; print the mem-word
0716   00D9 10 00 00 20 	SET R0, $20			; a space
0717   00DB 0C 00       	OUT
0718   00DC             	
0719   00DC EB 00       	INC R11				; increment memory pointer
0720   00DD DA 00       	DEC R10				; decrement word counter
0721   00DE D9 00       	DEC R9				; decrement page address counter
0722   00DF 2A 00       	LD R0, R10			; get word counter
0723   00E0 01 D6       	BGT nextword
0724   00E1             	
0725   00E1 29 00       	LD R0, R9  			; get page address counter
0726   00E2             	
0727   00E2 04 E8       	BLE nextline
0728   00E3 08 00 00 EB 	CALL CRLF
0729   00E5             	
0730   00E5 1A 00 00 16 	SET R10, $16		; reset word counter to 16
0731   00E7             	
0732   00E7 00 CD       	BRA nextaddress		    ; get address for next line
0733   00E8             
0734   00E8             nextline:
0735   00E8             	
0736   00E8 08 00 00 EB 	CALL CRLF			; two blank lines
0737   00EA             	
0738   00EA 00 47       	BRA NEXT
0739   00EB             
0740   00EB             CRLF:					; Output a CRLF
0741   00EB             
0742   00EB 2D 00       	LD R0, R13			; Get CR from R13
0743   00EC 0C 00       	OUT
0744   00ED 0B 03       	SBI 3				; Make a LF
0745   00EE 0C 00       	OUT
0746   00EF 09 00       	RET
0747   00F0             
0748   00F0             
0749   00F0             ; Hex_Dump 43 instructions
0750   00F0             
0751   00F0             ;--------------------------Arithmetic & Logic------------------------------------------------
0752   00F0             _add:	  
0753   00F0 A1 00       	  ADD R1    ; ADD
0754   00F1 00 47             BRA NEXT
0755   00F2             _sub:	  
0756   00F2 B1 00             SUB R1   ; SUB
0757   00F3 00 47             BRA NEXT
0758   00F4             _and:     
0759   00F4 81 00             AND R1    ; AND
0760   00F5 00 47             BRA NEXT
0761   00F6             _or:	  	  
0762   00F6 91 00             OR  R1    ; OR
0763   00F7 00 47             BRA NEXT
0764   00F8             _xor:
0765   00F8 F1 00             XOR  R1   ; XOR
0766   00F9 00 47             BRA NEXT
0767   00FA             _inv:	  
0768   00FA C1 00             INV  R1   ; INV
0769   00FB 00 47             BRA NEXT
0770   00FC             _inc:
0771   00FC E0 00             INC  R0      ; INC
0772   00FD 00 47             BRA NEXT
0773   00FE             _dec:	  
0774   00FE D0 00             DEC  R0      ; DEC
0775   00FF 00 47             BRA NEXT
0776   0100             	  
0777   0100             	; Arithmetic and logic operations  16 instructions  
0778   0100             ;----------------------------------------------------------------------------------------------------------		
0779   0100             
0780   0100             	  
0781   0100             	
0782   0100             .org $0100					; Start of the jump table	
0783   0100             	
0784   0100             ;------------------------------------------------------Jump_Table------------------------------------------
0785   0100             
0786   0100 F0 00               .WORD   $00F0     ; SPACE
0787   0101 F1 00               .WORD   $00F1     ; STORE !
0788   0102 F2 00               .WORD   $00F2     ; DUP   "
0789   0103 F3 00               .WORD   $00F3     ; LIT   #
0790   0104                     
0791   0104 F4 00               .WORD   $00F4     ; SWAP  $
0792   0105 F5 00               .WORD   $00F5     ; OVER  %
0793   0106 F4 00               .WORD   _and      ; AND   &
0794   0107 00 0F               .WORD   $0F00     ; quote ' 		
0795   0108                     
0796   0108 00 0F               .WORD   $0F00     ; BEGIN (
0797   0109 00 0F               .WORD   $0F00     ; END   )
0798   010A 00 0F               .WORD   $0F00     ; MUL   *
0799   010B F0 00               .WORD   _add      ; ADD   +     
0800   010C                     
0801   010C 00 0F               .WORD   $0F00     ; COMMA ,
0802   010D F2 00               .WORD   _sub      ; SUB   -     
0803   010E 4D 00               .WORD   Print_Num ; DOT   .     Print_Num  
0804   010F FF 00               .WORD   $00FF     ; DIV   /
0805   0110             		
0806   0110             		;ascii digits 0 to 9 are processed here
0807   0110             		
0808   0110 2B 00       		.WORD   number    ; process numeral '0'
0809   0111 2B 00       		.WORD   number    ; process numeral '1'
0810   0112 2B 00       		.WORD   number    ; process numeral '2'
0811   0113 2B 00       		.WORD   number    ; process numeral '3'
0812   0114 2B 00       		.WORD   number    ; process numeral '4'
0813   0115 2B 00       		.WORD   number    ; process numeral '5'
0814   0116 2B 00       		.WORD   number    ; process numeral '6'
0815   0117 2B 00       		.WORD   number    ; process numeral '7'
0816   0118 2B 00       		.WORD   number    ; process numeral '8'
0817   0119 2B 00       		.WORD   number    ; process numeral '9'
0818   011A             		       
0819   011A              
0820   011A                
0821   011A             ;-----------------------------------------Jump Table Contd-----------------------------------------
0822   011A                     
0823   011A 00 0F               .WORD   $0F00     ; CALL  :
0824   011B 00 0F               .WORD   $0F00     ; RET   ;
0825   011C 00 0F               .WORD   $0F00     ; LESS  <
0826   011D 00 0F               .WORD   $0F00     ; EQ    =
0827   011E             		
0828   011E 00 0F               .WORD   $0F00     ; MORE  >
0829   011F 00 0F               .WORD   $0F00     ; QUERY ?
0830   0120 A0 00               .WORD   $00A0     ; FETCH @
0831   0121 20 04       		.WORD   $0420     ; A
0832   0122                     
0833   0122 40 04               .WORD   $0440     ; B
0834   0123 60 04               .WORD   $0460     ; C
0835   0124 80 04               .WORD   $0480     ; D
0836   0125 A0 04               .WORD   $04A0     ; E
0837   0126             
0838   0126 C0 04               .WORD   $04C0     ; F
0839   0127 E0 04               .WORD   $04E0     ; G
0840   0128 00 05               .WORD   $0500     ; H
0841   0129 20 05               .WORD   $0520     ; I
0842   012A                     
0843   012A 40 05               .WORD   $0540     ; J
0844   012B 60 05               .WORD   $0560     ; K
0845   012C 80 05               .WORD   $0580     ; L
0846   012D A0 05               .WORD   $05A0     ; M
0847   012E             
0848   012E C0 05               .WORD   $05C0     ; N
0849   012F E0 05               .WORD   $05E0     ; O
0850   0130 00 06               .WORD   $0600     ; P
0851   0131 20 06               .WORD   $0620     ; Q
0852   0132             
0853   0132 60 06       		.WORD   $0660     ; R
0854   0133 80 06               .WORD   $0680     ; S
0855   0134 A0 06               .WORD   $06A0     ; T
0856   0135 C0 06               .WORD   $06C0     ; U
0857   0136             
0858   0136 E0 06               .WORD   $06E0     ; V
0859   0137 00 07               .WORD   $0700     ; W
0860   0138 20 07               .WORD   $0720     ; X
0861   0139 40 07               .WORD   $0740     ; Y
0862   013A             		
0863   013A 60 07       		.WORD   $0760     ; Z
0864   013B             			
0865   013B 00 0F               .WORD   $0F00     ; OPEN  [
0866   013C             		
0867   013C 00 0F               .WORD   $0F00     ; BACK  
0868   013D 00 0F               .WORD   $0F00     ; CLOSE ]        
0869   013E F8 00               .WORD   _xor      ; XOR   ^      
0870   013F 00 0F               .WORD   $0F00     ; UNDER _
0871   0140             		
0872   0140 00 0F               .WORD   $0F00     ; TICK  
0873   0141 00 0F               .WORD   $0F00     ; a
0874   0142                     
0875   0142 A8 00               .WORD   $00A8     ; b
0876   0143 00 0F               .WORD   $0F00     ; c
0877   0144 00 0F               .WORD   $0F00     ; d
0878   0145 00 0F               .WORD   $0F00     ; e
0879   0146             
0880   0146 00 0F               .WORD   $0F00     ; f
0881   0147 00 0F               .WORD   $0F00     ; g
0882   0148 00 0F               .WORD   $0F00     ; h
0883   0149 00 0F               .WORD   $0F00     ; i
0884   014A                     
0885   014A B0 00               .WORD   $00B0     ; j
0886   014B 00 0F               .WORD   $0F00     ; k
0887   014C 00 0F               .WORD   $0F00     ; l
0888   014D 00 0F               .WORD   $0F00     ; m
0889   014E             
0890   014E 00 0F               .WORD   $0F00     ; n
0891   014F 00 0F               .WORD   $0F00     ; o
0892   0150 00 0F               .WORD   $0F00     ; p
0893   0151 00 0F               .WORD   $0F00     ; q
0894   0152             
0895   0152 B8 00               .WORD   $00B8     ; r
0896   0153 00 0F               .WORD   $0F00     ; s
0897   0154 00 0F               .WORD   $0F00     ; t
0898   0155 00 0F               .WORD   $0F00     ; u
0899   0156             
0900   0156 00 0F               .WORD   $0F00     ; v
0901   0157 00 0F               .WORD   $0F00     ; w
0902   0158 00 0F               .WORD   $0F00     ; x
0903   0159 00 0F               .WORD   $0F00     ; y
0904   015A                 
0905   015A 00 0F               .WORD   $0F00     ; z
0906   015B 00 0F               .WORD   $0F00     ; BRACEL {
0907   015C F6 00               .WORD   _or       ; OR     |   
0908   015D 00 0F               .WORD   $0F00     ; BRACER {
0909   015E                     
0910   015E FA 00               .WORD   _inv      ; INV    ~   
0911   015F 00 0F               .WORD   $0F00     ; NOP
0912   0160             		
0913   0160             		
0914   0160             		; Jump_Table  96 words
0915   0160                                   
0916   0160             ;----------------------------End of Jump Table-----------------------------------------------	
0917   0160             
0918   0160             .end	
ADDR  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
-----------------------------------------------------
0000  00 74 18 00 02 00 E8 00 48 00 34 00 0B 0D 06 25
0010  24 00 0B 0A 06 25 24 00 0B 20 04 24 24 00 0B 7F
0020  03 24 24 00 0B 3E 05 21 08 00 00 74 0B 50 A0 00
0030  A0 00 A0 00 A0 00 A0 00 A8 00 32 00 24 00 52 00
0040  00 24 E8 00 24 00 58 00 00 74 10 00 00 80 58 00
0050  18 00 02 00 00 47 17 00 00 00 18 00 02 00 48 00
0060  34 00 E8 00 48 00 0B 30 02 42 0B 0A 03 42 24 00
0070  0B 30 A7 00 35 00 A5 00 A0 00 A0 00 A5 00 A5 00
0080  37 00 00 2F 24 00 A7 00 32 00 17 00 00 00 E8 00
0090  48 00 0A E0 33 00 43 00 00 E0 12 00 00 00 1D 00
00A0  00 0D 11 00 27 10 08 00 00 67 11 00 03 E8 08 00
00B0  00 67 11 00 00 64 08 00 00 67 11 00 00 0A 08 00
00C0  00 67 0A 30 0C 00 B4 00 08 00 00 EB 00 47 B1 00
00D0  02 6B E2 00 00 67 34 00 22 00 0A 30 0C 00 24 00
00E0  A1 00 12 00 00 00 09 00 0D 00 11 00 02 00 41 00
00F0  0C 00 E1 00 01 77 00 03 11 00 02 00 17 00 00 00
0100  41 00 34 00 E1 00 41 00 0B 30 02 91 0B 17 03 91
0110  08 00 00 95 A7 00 A0 00 A0 00 A0 00 A0 00 37 00
0120  00 80 08 00 00 95 A7 00 00 4D 24 00 0B 40 02 9A
0130  0A 09 00 9C 24 00 0B 30 09 00 12 00 00 00 11 00
0140  10 00 08 00 00 AE 11 00 01 00 08 00 00 AE 11 00
0150  00 10 08 00 00 AE 08 00 00 BB 09 00 B1 00 02 B2
0160  E2 00 00 AE 34 00 22 00 08 00 00 BB 24 00 A1 00
0170  12 00 00 00 09 00 0A 30 36 00 0B 3A 02 C2 0A 41
0180  0C 00 00 C4 26 00 0C 00 09 00 1D 00 00 0D 19 00
0190  01 00 1A 00 00 0A 1B 00 00 00 2B 00 08 00 00 9D
01A0  10 00 00 3E 0C 00 0B 1E 0C 00 0C 00 4B 00 08 00
01B0  00 9D 10 00 00 20 0C 00 EB 00 DA 00 D9 00 2A 00
01C0  01 D6 29 00 04 E8 08 00 00 EB 1A 00 00 16 00 CD
01D0  08 00 00 EB 00 47 2D 00 0C 00 0B 03 0C 00 09 00
01E0  A1 00 00 47 B1 00 00 47 81 00 00 47 91 00 00 47
01F0  F1 00 00 47 C1 00 00 47 E0 00 00 47 D0 00 00 47
0200  F0 00 F1 00 F2 00 F3 00 F4 00 F5 00 F4 00 00 0F
0210  00 0F 00 0F 00 0F F0 00 00 0F F2 00 4D 00 FF 00
0220  2B 00 2B 00 2B 00 2B 00 2B 00 2B 00 2B 00 2B 00
0230  2B 00 2B 00 00 0F 00 0F 00 0F 00 0F 00 0F 00 0F
0240  A0 00 20 04 40 04 60 04 80 04 A0 04 C0 04 E0 04
0250  00 05 20 05 40 05 60 05 80 05 A0 05 C0 05 E0 05
0260  00 06 20 06 60 06 80 06 A0 06 C0 06 E0 06 00 07
0270  20 07 40 07 60 07 00 0F 00 0F 00 0F F8 00 00 0F
0280  00 0F 00 0F A8 00 00 0F 00 0F 00 0F 00 0F 00 0F
0290  00 0F 00 0F B0 00 00 0F 00 0F 00 0F 00 0F 00 0F
02A0  00 0F 00 0F B8 00 00 0F 00 0F 00 0F 00 0F 00 0F
02B0  00 0F 00 0F 00 0F 00 0F F6 00 00 0F FA 00 00 0F


tasm: Number of errors = 0
