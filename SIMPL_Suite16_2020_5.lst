0001   0000             ; 	SIMPL is a tiny Forth-like, extensible stack based language used to exercise the Suite_16 instruction set
0002   0000             ; 	and provide useful programming debugging facilities
0003   0000             
0004   0000             ;	A Forth-Like Language in under 2048 bytes
0005   0000             ; 
0006   0000             ; 	SIMPL_Suite16_2020_5.asm
0007   0000             
0008   0000             ; 	Ken Boak January 2020 
0009   0000             
0010   0000             ; 	To assemble: use tasm -s -h -c -g0 -t16 SIMPL_Suite16_2020_5.asm out.hex
0011   0000             
0012   0000             ;----------------------------------------How SIMPL Works-----------------------------------------------
0013   0000             
0014   0000             ; SIMPL provides an interpreter framework for sequentially executing single character commands from a text buffer
0015   0000             
0016   0000             ; R8 is the instruction pointer, IP which points to the current character in the text buffer
0017   0000             ; Fetch the character and use it to index into a jump table
0018   0000             
0019   0000             ; The jump table associates a code field address with each character
0020   0000             ; Using this code field address we jump to the start of some action routine
0021   0000             
0022   0000             ; We need to determine whether the characers form part of a number
0023   0000             ; these must be decoded separately and put on the stack - using the "number" routine
0024   0000             
0025   0000             ; The character is either a number, a primitive or an alpha - so look up the jump address
0026   0000             ; If it's a primitive symbol or lowercase alpha between 0x20 and 0x2F or >$39
0027   0000             ; point to a look-up table and fetch it's code segment address
0028   0000             
0029   0000             ; If the character is a numeral between ascii $30 and $39 jump to the "number" routine to process the digit
0030   0000             ; Numbers are enummerated as 16-bit integers and put onto the stack by the number routine
0031   0000             
0032   0000             ; If the character is an ALPHA user word - it will execute from a fixed address stored in the jump table
0033   0000             ; Each table entry jumps to a unique address and executes the code found at that code address
0034   0000             
0035   0000             ; After execution of the code block, each executed word jumps back to NEXT
0036   0000             ; The NEXT routine fetches the next ascii character instruction from memory and the process repeats
0037   0000             
0038   0000             ;----------------------------------------------------------------------------------------------------------
0039   0000             ;
0040   0000             ; 	This code contains the framework routines and main utility routines for SIMPL coded for the Suite-16 cpu
0041   0000             ;	Additional primitives or functions can easily be added at a later date, using this framework
0042   0000             
0043   0000             ;	Framework Routines
0044   0000             
0045   0000             ;	Text_Read   Get a character from the UART and store it in the text buffer
0046   0000             ;	Text_Check  Examine the character to determine if a number, an alpha, a symbol, a colon or terminator  
0047   0000             ;   Number      If numerical ascii characters are found - form a 16-bit integer and put it on the stack
0048   0000             ;   Jump_Table  Look up the code address associated with the character and jump to it.
0049   0000             ;   Execute     Run the action routine associated with the character - then jump back to NEXT
0050   0000             ;   NEXT        Fetch the next character from the instruction buffer
0051   0000             ;
0052   0000             ;	Utility Routines
0053   0000             ;
0054   0000             ; 	Get_Number  Read the text buffer for decimal characters and form a 16-bit integer
0055   0000             ; 	Print_Num   Print a 5 digit decimal number from a 16-bit integer
0056   0000             ; 	Get_Hex     Read the text buffer for hexidecimal characters and form a 16-bit integer
0057   0000             ; 	Print_Hex   Print a 4 digit hexadecimal number from a 16-bit integer
0058   0000             ; 	HexDump		Display a block of memory in the usual hex dup fashion
0059   0000             ;   Hex_Load	Load a hex file into memory
0060   0000             
0061   0000             ; 	To assemble: use tasm -s -h -c -g0 -t16 SIMPL_Suite16_2020_5.asm out.hex
0062   0000             
0063   0000             ;-------------------------------------------------------------------------------
0064   0000             ; Memory Map - initial implementation
0065   0000             
0066   0000             ; $0000   Start
0067   0000             ; $0000   Interpreter framework: Text_Read, number, next
0068   0000             ; $004D   Utility Print_Num
0069   0000             ; $0074	  Utility getchar
0070   0000             ; $007C   Utility Get_Hex
0071   0000             ; $009D   Utility Print_Hex
0072   0000             ; $00C5	  Utility Hex_Dump
0073   0000             ; $00F0   Utility crlf, puts, putc
0074   0000             ; $0100   Jump Table			$60 words	
0075   0000             ; $0160   Utility Hex_Loader	$A0 words
0076   0000             ; $0200	  Utility Arithmetic & Logic 	 
0077   0000             ; $0220	  Action Routines		$200 words
0078   0000             ; $0420   User Words        	$360 words
0079   0000             ; $0780   Text Input Buffer 	$20 words
0080   0000             ; $07A0   RAM (stacks etc)		$60 words
0081   0000             ; $07FF	  Top of RAM
0082   0000              
0083   0000             ;--------------------------------------------TO DO---------------------------------
0084   0000             
0085   0000             ; Loops, I/O, Strings and Delays to be added
0086   0000             
0087   0000             ; This version 921600 baud serial communications
0088   0000             
0089   0000             ; Input and output to UART Port P2 of Nucleo STM32H743 added with "i" and "o" commands
0090   0000             
0091   0000             ;-------------------------------------------------------------------------------
0092   0000             
0093   0000             ; Primitive Instructions - commence at $0200
0094   0000             
0095   0000             ; These allow basic maths and logical instructions on 16-bit integers     +  -  /  *  &  |   ^   ~
0096   0000             ; Stack Manipulation   DUP DROP PUSH POP SWAP OVER
0097   0000             ; Memory transfers with FETCH and STORE
0098   0000             ; Compilation mode with : and ;
0099   0000             ; Simple decrementing loops   (..........)
0100   0000             ; Input and Output
0101   0000             ; Print a string contained between underscores example: _Hello World_
0102   0000             
0103   0000             ; Note as of 22-01-2020 - not all of these are fully implemented
0104   0000             
0105   0000             ;   Primitives based on ascii symbols - implemented in memory $0200 to $0420:
0106   0000             
0107   0000             ;	ADD       +
0108   0000             ;	SUB       -
0109   0000             ;	SHR       /    shift right  (divide by 2)
0110   0000             ;	SHL       *    shift left   (multiply by 2)
0111   0000             ;	AND       &
0112   0000             ;	OR        |
0113   0000             ;	XOR       ^
0114   0000             ;	INV       ~
0115   0000             ;	DUP       “    Duplicate the top member of the stack
0116   0000             ;	DROP      `    Drop the top member of the stack
0117   0000             ;	PUSH      ,
0118   0000             ;	POP       ‘
0119   0000             ;	SWAP      $    Swap the top and 2nd members of the stack
0120   0000             ;	OVER      %
0121   0000             ;	FETCH     @
0122   0000             ;	STORE     !
0123   0000             ;	CALL      :
0124   0000             ;	RETURN    ;
0125   0000             ;	JMP       \
0126   0000             ;	JE        =    Jump if top = 0
0127   0000             ;	JGT       >    Jump if top > 0 
0128   0000             ;	JLT       <    Jump if top < 0
0129   0000             ;	TO-R      {    Copy top to return stack
0130   0000             ;	FROM-R    }    Copy return stack to top
0131   0000             ;	LOOP-Strt (    
0132   0000             ;	LOOP-End  )
0133   0000             ;	IN        [    Get a byte from the port addressed by top
0134   0000             ;	OUT       ]    Send a byte from 2nd to the port addressed by top
0135   0000             ;	KEY       ?    Get a character from serial port
0136   0000             ;	PRINT     _    _Print the text string enclosed between the underscores_
0137   0000             ;	NOP       Space
0138   0000             ;   LIT       #	   Put the following literal into top
0139   0000             
0140   0000             ;-------------------------------------------------------------------------------
0141   0000             
0142   0000             ;	Lower case letters are used to execute more complex built in routines:
0143   0000             
0144   0000             ;	a
0145   0000             ;	b		fetch a block of code via serial port
0146   0000             ;	c
0147   0000             ;	d		dump a block of code
0148   0000             ;	e		execute code at a given block address
0149   0000             ;	f
0150   0000             ;	g
0151   0000             ;	h       set port pin high
0152   0000             ;	i       input byte from port
0153   0000             ;	j
0154   0000             ;	k       access the loop counter variable
0155   0000             ;	l       set port pin low
0156   0000             ;	m       milliseconds delay
0157   0000             ;	n
0158   0000             ;	o       output byte to port
0159   0000             ;	p       print the top of stack to terminal as a 16-bit integer
0160   0000             ;	q       print the ascii character at given RAM location
0161   0000             ;	r       read input pin
0162   0000             ;	s       sample the ADC
0163   0000             ;	t
0164   0000             ;	u       microseconds delay
0165   0000             ;	v		define a variable
0166   0000             ;	w
0167   0000             ;	x
0168   0000             ;	y
0169   0000             ;	z
0170   0000             
0171   0000             ; ---------------------------------------User Defined Words----------------------------------------
0172   0000             
0173   0000             ;		Upper case letters A to Z are used to define 26, User "Words"
0174   0000             
0175   0000             ;       They are allocated fixed addresses at $20 word intervals, starting at $0420.  A = $0420, Z = $0760
0176   0000             ;       
0177   0000             
0178   0000             ;		User Routines are defined by capital letters starting  with colon : and end with semicolon ;
0179   0000             
0180   0000             ;		eg  :F10(100mh200ml);		;	Flash the led 10 times - high for 100mS and low for 200mS
0181   0000             
0182   0000             ;		You can play sequences of notes (tunes) ABC etc through a small speaker  
0183   0000             ; 		Some common notes are defined as follows
0184   0000             
0185   0000             ;		:A40{h1106ul1106u);			 musical note A
0186   0000             ;		:B5{h986ul986u);			 musical note B
0187   0000             ;       :C51{h929ul929u);			 musical note C
0188   0000             ;       :D57{h825ul825u);			 musical note D
0189   0000             ;       :E64{h733ul733u);			 musical note E
0190   0000             ;       :F72{h690ul691u);			 musical note F
0191   0000             ;       :G81{h613ul613u);			 musical note G
0192   0000             
0193   0000             ;       :H_Hello World, and welcome to SIMPL_;   A Banner Message
0194   0000             
0195   0000             ; The following 26 commands are normally available to users - shown here with starting address
0196   0000             
0197   0000             ;	A			$0420
0198   0000             ;	B			$0440			
0199   0000             ;	C			$0460
0200   0000             ;	D			$0480
0201   0000             ;	E			$04A0
0202   0000             ;	F			$04C0
0203   0000             ;	G			$04E0
0204   0000             ;	H			$0500
0205   0000             ;	I			$0520
0206   0000             ;	J			$0540
0207   0000             ;	K			$0560
0208   0000             ;	L			$0580
0209   0000             ;	M			$05A0
0210   0000             ;	N			$05C0
0211   0000             ;	O			$05E0
0212   0000             ;	P			$0600
0213   0000             ;	Q			$0620
0214   0000             ;	R			$0640
0215   0000             ;	S			$0660
0216   0000             ;	T			$0680
0217   0000             ;	U			$06A0
0218   0000             ;	V			$06C0
0219   0000             ;	W			$0700
0220   0000             ;	X			$0720
0221   0000             ;	Y			$0740
0222   0000             ;	Z			$0760			
0223   0000             
0224   0000             ;-------------------------------------------------------------------------------
0225   0000             
0226   0000             ;   Examples of SIMPL phrases
0227   0000             
0228   0000             ; 	eg add 123 and 456 and print the result to the terminal
0229   0000             
0230   0000             ; 	123 456+p
0231   0000             
0232   0000             ;	Loop 10 times printing "Spurs are Fab!"
0233   0000             
0234   0000             ; 	10(_Spurs are Fab!_)
0235   0000             
0236   0000             ;   Flash a LED 10 times 100mS on 200mS off
0237   0000             
0238   0000             ;   10(h100ml200m)
0239   0000             
0240   0000             
0241   0000             ;   Toggle a port pin at 1MHz   1000(hlhlhlhlhlhlhlhlhlhl)
0242   0000             
0243   0000             ;-------------------------------------------------------------------------------
0244   0000             
0245   0000             
0246   0000             
0247   0000             ;   SIMPL is basically a character interpreter based on a switch statement contained within a loop
0248   0000             
0249   0000             ; 	In assembly language the switch statement is usually best implemented as a jump table.
0250   0000             ;   An Instruction Pointer IP, selects the next instruction from an array of characters in RAM
0251   0000             ;   Unlike Forth that uses words stored in a dictionary, SIMPL uses single printable ascii characters
0252   0000             ;   These characters are chosen to either be familiar symbols (+ -  * / etc) or have a high mnemonic value
0253   0000             ;   The ascii character command is used as an index into the jump table
0254   0000             ; 	The jump table contains the starting addresses of all the primitive commands and routines.
0255   0000             ;   After indexing into the table, the interpreter jumps to the address it finds and then executes code
0256   0000             ;   starting from that address.
0257   0000             ; 	At the end of the code block, the interpreter jumps back to NEXT, to fetch the next command.
0258   0000             
0259   0000             ;-------------------------------------------------------------------------------------------------
0260   0000             
0261   0000             ; Register Usage and constants
0262   0000             
0263   0000             
0264   0000             ; CPU registers - yet to be fully defined for Suite_16
0265   0000             
0266   0000             ; Register Usage
0267   0000             
0268   0000             ;	tos: 			.EQU R0			; top of stack
0269   0000             ;	sos:			.EQU R1			; second on stack
0270   0000             ;	temp2:			.EQU R2
0271   0000             ;	temp3:			.EQU R3
0272   0000             ;	temp4:			.EQU R4
0273   0000             ;	stack: 			.EQU R5
0274   0000             ;	scratch6:		.EQU R6
0275   0000             ;	temp7: 			.EQU R7			; loop start
0276   0000             ;	ip: 			.EQU R8			; instruction pointer
0277   0000             ;	temp9: 			.EQU R9			; millisecond delay
0278   0000             ;	temp10: 		.EQU R10        ; microsecond delay
0279   0000             ;	temp11:			.EQU R11		; scratch
0280   0000             ;	instr: 			.EQU R12		; instruction fetched into R12 for decoding
0281   0000             ;	temp13:			.EQU R13		; arithmetic / scratch
0282   0000             ;	temp14: 		.EQU R14		; used for buffer pointer
0283   0000             ;	RSP: 			.EQU R15	    ; Return from alpha  next IP
0284   0000             
0285   0000             ;-------------------------------------------------------------------------------
0286   0000             ; 	Implementing the Initialisation, TextTead, TextEval and UART routines in Suite_16 assembly language
0287   0000             
0288   0000             ;   The core of the SIMPL interpreter is coded as these short routines:
0289   0000             
0290   0000             ;	Text_Read   Get a character from the UART and store it in the text buffer
0291   0000             ;	Text_Check  Check the character to determine it is a valid character or a terminator
0292   0000             ;				(Valid characters are ascii $20 to $7F and may be a symbol, a number, an alpha, or a colon)
0293   0000             ;				Colon signifies a new definition is being written, and subsequent text is treated differently   
0294   0000             ;   Number      If numerical ascii characters are found - form a 16-bit integer and put it on the stack
0295   0000             ;   Jump_Table  Look up the code address associated with the character and jump to it.
0296   0000             ;   Execute     Run the action routine associated with the character - then jump back to NEXT
0297   0000             ;   NEXT        Fetch the next character from the instruction buffer
0298   0000             
0299   0000             ;	SIMPL has an immediate mode - where a phrase of commands typed at the keyboard will be executed
0300   0000             ;	immediately after the return key is pressed.
0301   0000             
0302   0000             ;	It also has a "colon definition" mode - If the first character in the text buffer is a colon it
0303   0000             ;   will define a new word - based on the uppercase ALPHA character that immediately follows the colon.
0304   0000             ;   This new definition will be stored in RAM at a fixed address.
0305   0000              
0306   0000             ;	32 bytes of storage is allocated in RAM for each ALPHA character.
0307   0000             ;   This limitation means that definitions are kept short, concise, and can be chained together to form
0308   0000             ; 	larger program constructs.
0309   0000             
0310   0000             ;----------------------------------------------------------------------------------------------------------
0311   0000             
0312   0000             EOS:         	.EQU $0000      	; End of string
0313   0000             
0314   0000             .org $0000
0315   0000             start:
0316   0000             
0317   0000             ;--------------------------------------Text_Read-----------------------------------------------------------
0318   0000             ;
0319   0000             ; Text_Read - This implements the SIMPL interpreter in Suite_16 assembly Language
0320   0000             ;
0321   0000             ;----------------------------------------------------------------------------------------------------------
0322   0000             
0323   0000             ; Get a character from the UART and store it in the input buffer starting at 0x0780
0324   0000             
0325   0000             ; Supports immediate mode - where characters are stored at 0x200 and executed directly
0326   0000             ; Supports compiled mode - where string starts with a colon and the next character "NAME" is an upper case alpha
0327   0000             ; String is stored at 0x400 plus a multiple of 32 byte offset according to the value of "NAME"
0328   0000             
0329   0000             ; Register Usage 
0330   0000             
0331   0000             ;  The input buffer - starts at $0780
0332   0000             ;  R0 receives the next character from the text buffer pointed to by R8
0333   0000             ;  Test it against CR, NL, unprintable characters and colon
0334   0000             ;  If it starts with a colon - get the next character (the NAME) and store at a specific location in memory
0335   0000             ;  If it does not start with a colon, interpret and execute each character in turn
0336   0000             
0337   0000             ;----------------------------------------------------------------------------------------------------------
0338   0000             
0339   0000             Text_Read:
0340   0000             
0341   0000 00 72           BRA getchar             ; Get the input buffer from the UART
0342   0001             	
0343   0001 18 00 07 80 	SET R8, $780			; R8 points to char buffer
0344   0003             		
0345   0003             Text_Check:
0346   0003             
0347   0003 E8 00           INC R8					; Get the next character from the buffer
0348   0004             	
0349   0004 48 00       	LD  R0, @R8				; Get it's ascii value into the accumulator
0350   0005             	
0351   0005 34 00       	ST  R4, R0			    ; Temporary store in R4
0352   0006             	
0353   0006 0B 0D       	SBI $0D					; Is it a carriage return?
0354   0007 06 25       	BEQ textEnd
0355   0008 24 00       	LD  R0,R4
0356   0009 0B 0A       	SBI $0A					; Is it a newline?
0357   000A 06 25       	BEQ textEnd
0358   000B 24 00       	LD  R0,R4
0359   000C 0B 20       	SBI $20					; Is it unprintable - Too low?
0360   000D 04 24       	BLE nonValid
0361   000E 24 00       	LD  R0,R4
0362   000F 0B 7F       	SBI $7F					; Is it unprintable - Too High?
0363   0010 03 24       	BGE nonValid
0364   0011 24 00       	LD  R0,R4
0365   0012 0B 3E       	SBI $3E					; Is it a colon?
0366   0013 05 21       	BNE notColon
0367   0014             	
0368   0014             Colon:						; If the input character is a colon
0369   0014             
0370   0014 08 00 00 72 	CALL    getchar    	    ; get the next character - which is the NAME
0371   0016 0B 50       	SBI     $50				; subtract ascii "A" - $11 from R0 - puts it on $20 boundaries starting	at $220
0372   0017 A0 00       	ADD		R0				; x2
0373   0018 A0 00       	ADD		R0				; x4
0374   0019 A0 00       	ADD		R0				; x8
0375   001A A0 00       	ADD     R0				; x16
0376   001B A0 00       	ADD		R0				; x32
0377   001C             	
0378   001C A8 00       	ADD		R8				; Add to the instruction pointer R8
0379   001D 32 00       	ST		R2, R0			; Temporary store this buffer address in R2
0380   001E 24 00       	LD		R0, R4			; Get the character back
0381   001F 52 00       	ST      @R2, R0			; Store it in the correct place in correct definition buffer
0382   0020             	
0383   0020 00 24       	BRA		nonValid		; move on to next step
0384   0021             
0385   0021             notColon:		
0386   0021 E8 00       	INC   R8                ; Increment buffer pointer R8
0387   0022 24 00       	LD	  R0, R4			; Get the character back
0388   0023 58 00       	ST    @R8, R0			; Store character in RAM buffer indexed by R8
0389   0024             
0390   0024             nonValid:
0391   0024             
0392   0024 00 72       	BRA   getchar
0393   0025             	
0394   0025             textEnd:		
0395   0025             
0396   0025 10 00 00 80 	SET R0, $80
0397   0027 58 00       	ST	@R8, R0				; Put a null terminating (0x80) zero on the end of the buffer
0398   0028 18 00 07 80 	SET R8, $0780			; set ip (instruction pointer) - to start of input buffer in RAM at address 0x0200
0399   002A 00 47       	BRA	    NEXT			; get the next instruction
0400   002B             
0401   002B             ; Text_Read  43 Instruction words
0402   002B             	
0403   002B             ;---------------------------------------------Number--------------------------------------------------------	
0404   002B             	
0405   002B             	
0406   002B             number:						; Accept up to 5 decimal digits from serial and put into memory as 16-bit integer
0407   002B             
0408   002B 17 00 00 00 	SET R7, 0		    	; Clear R7	
0409   002D 18 00 07 80 	SET R8, $0780		    ; R8 points to char buffer
0410   002F             	
0411   002F             number1:	
0412   002F             	
0413   002F 48 00       	LD R0, @R8				; Get the first character	
0414   0030 34 00       	ST R4, R0				; Temporary store in R4
0415   0031             	
0416   0031 E8 00       	INC R8					; Point to next character	
0417   0032 48 00       	LD R0, @R8				; Get the next character
0418   0033             	
0419   0033 0B 30       	SBI  $30				; Is it bigger than $30 ?	
0420   0034 02 42       	BLT endNumber
0421   0035             	
0422   0035 0B 0A       	SBI $0A					; Is it less than $10	
0423   0036 03 42       	BGE endNumber
0424   0037             	
0425   0037 24 00       	LD R0, R4				; Get original character back
0426   0038 0B 30       	SBI  $30				; Form an ascii digit
0427   0039             	
0428   0039 A7 00       	ADD R7					; Add in accumulating total from R7
0429   003A             	
0430   003A             times10:	
0431   003A             	
0432   003A 35 00       	ST R5,R0				; Digit is now in R5	
0433   003B A5 00       	ADD R5					; R0 = 2 Times R0 
0434   003C A0 00       	ADD R0					; 4X
0435   003D A0 00       	ADD R0					; 8X
0436   003E A5 00       	ADD R5					; 9X
0437   003F A5 00       	ADD R5					; 10X
0438   0040             	
0439   0040 37 00       	ST R7, R0				; R7 is accumulation of all the digits multiplied by powers of 10
0440   0041             	
0441   0041 00 2F       	BRA number1				; go around and process the remaining digits
0442   0042             	
0443   0042             endNumber:
0444   0042             
0445   0042 24 00       	LD R0, R4				; Get the last digit back	
0446   0043 A7 00       	ADD R7					; Add in the accumulated sum
0447   0044 32 00       	ST  R2,R0				; Temporary store integer number in scratch reg R2
0448   0045             	
0449   0045 17 00 00 00 	SET R7,0				; Don't forget to clear R7
0450   0047             	
0451   0047             ; number  28 Instruction words	
0452   0047             
0453   0047             ;---------------------------------------------Next-------------------------------------------------------
0454   0047             ; Next fetches the next instruction and decides what to do with it
0455   0047             ; The character is either a primitive or an ALPHA - so index into jump table to get the execution address 
0456   0047             ; Restore R to start of RAM buffer
0457   0047             
0458   0047             NEXT:
0459   0047             
0460   0047 E8 00       	INC R8					; Point to the next character
0461   0048 48 00       	LD R0, @R8				; Get the next character into R0
0462   0049 0A E0       	ADI $E0					; Add $E0 to form an address in the jump table range of $100 to $15F
0463   004A 33 00       	ST R3,R0				; Temporary store to R3
0464   004B             	
0465   004B 43 00       	LD R0, @R3				; Index into jump table	
0466   004C 00 E0       	.WORD $E000             ; JMP @ R0 Jump to the command routine (if its a ascii numeral - jump to number routine)
0467   004D             
0468   004D             ; next 6 Instruction words	
0469   004D             	
0470   004D             ;-----------------------------------------Print_Num---------------------------------------------
0471   004D             
0472   004D             ; Print_Num  Take the 16 bit value in top of stack register and prints it to terminal as an integer
0473   004D             ; Method -  repeated subtraction of powers of 10
0474   004D             
0475   004D             Print_Num:
0476   004D             
0477   004D                 ;  Prints out the value of R0 as a 5 digit decimal number to the terminal
0478   004D                 ;  Leading zeroes are not suppressed
0479   004D                 ;  R1 = Decimation Value
0480   004D                 ;  R2 = current digit 
0481   004D                 ;  R4 = temporary storage for accumulator (decimated value)
0482   004D             	
0483   004D 12 00 00 00 	SET R2, 0
0484   004F             	
0485   004F 11 00 27 10 	SET R1, 10000
0486   0051 08 00 00 65 	CALL decimate
0487   0053             	
0488   0053 11 00 03 E8 	SET R1, 1000
0489   0055 08 00 00 65 	CALL decimate
0490   0057             	
0491   0057 11 00 00 64 	SET R1, 100
0492   0059 08 00 00 65 	CALL decimate
0493   005B             	
0494   005B 11 00 00 0A 	SET R1, 10
0495   005D 08 00 00 65 	CALL decimate
0496   005F             	
0497   005F 0A 30       	ADI $30					; make the value an ascii numeral
0498   0060 0C 00       	OUT						; print to terminal
0499   0061 B4 00       	SUB R4
0500   0062             	
0501   0062 08 00 00 EF 	CALL crlf				; Output a CRLF
0502   0064             	
0503   0064 00 47       	BRA NEXT
0504   0065             		
0505   0065             decimate:
0506   0065             
0507   0065 B1 00       	SUB R1					; subtract the power of 10 until R0 goes negative
0508   0066 02 69           BLT value
0509   0067 E2 00           INC R2					; keep a count of how many times you subtract the decimation factor
0510   0068 00 65           BRA decimate	
0511   0069             	
0512   0069             value:
0513   0069             
0514   0069 34 00       	ST R4, R0
0515   006A 22 00       	LD R0, R2
0516   006B 0A 30       	ADI $30				    ; Add 0x30 to make R0 a printable digit
0517   006C 0C 00       	OUT						; print a digit
0518   006D             	
0519   006D 24 00       	LD R0, R4
0520   006E A1 00       	ADD R1
0521   006F 12 00 00 00 	SET R2, 0				; reset R2
0522   0071             	
0523   0071 09 00       	RET
0524   0072             	
0525   0072             ; Print_Num   39 instruction words	
0526   0072             	
0527   0072             	
0528   0072             ;------------------------------------------------getchar-----------------------------------------------
0529   0072             ; 	
0530   0072             getchar:	
0531   0072             	
0532   0072             
0533   0072 0D 00       	IN						; Get character
0534   0073             	
0535   0073 11 00 07 80 	SET R1, $0780			; R1 points to char buffer
0536   0075             	
0537   0075             loop1:	
0538   0075 41 00       	LD R0, @R1				; get first character
0539   0076 0C 00       	OUT                     ; output character
0540   0077 E1 00       	INC R1
0541   0078 01 75       	BGT loop1				; get characters until you find an EOS
0542   0079 00 03       	BRA Text_Check		    ; Back to Text_Check when you get an EOS
0543   007A             	
0544   007A             	; getchar  8 instructions 
0545   007A             	
0546   007A             ;-----------------------------------------Get_Hex---------------------------------------------
0547   007A             	
0548   007A             Get_Hex:
0549   007A             
0550   007A             	; Accepts a hexadecimal number up to FFFF from terminal input buffer
0551   007A             	; converts it to an integer and puts it into register R0
0552   007A             	; It can then be printed out as a decimal using Print_Num - for checking integrity
0553   007A             	; R1 is the pointer in the text buffer - which starts at 0x0780
0554   007A             	; R4 is used as a temporary store for the character in the accumulator R0
0555   007A             	; R5 is used in the "Times 16" routine
0556   007A             	; R7 is used to accumulate the powers of 16 when forming the integer in R0
0557   007A             	
0558   007A 11 00 07 80 	SET R1, $0780				; R1 is start of text buffer
0559   007C 17 00 00 00 	SET R7, 0				; Clear R7
0560   007E             
0561   007E             nextchar:
0562   007E             
0563   007E 41 00       	LD R0, @R1				; get the first character
0564   007F 34 00       	ST R4, R0				; temporary store
0565   0080 E1 00       	INC R1
0566   0081 41 00       	LD R0, @R1				; get the next character to see if it is numeric or terminator
0567   0082             	
0568   0082 0B 30       	SBI $30					; Is it bigger than 0x30?
0569   0083 02 8F       	BLT quit
0570   0084 0B 17       	SBI 23					; Is is bigger than ascii 'F'
0571   0085 03 8F       	BGE quit
0572   0086             	
0573   0086 08 00 00 93 	CALL modify
0574   0088             	
0575   0088 A7 00       	ADD R7
0576   0089 A0 00       	ADD R0					; 2X
0577   008A A0 00       	ADD R0					; 4X
0578   008B A0 00       	ADD R0					; 8X
0579   008C A0 00       	ADD R0					; 16X
0580   008D             	
0581   008D 37 00       	ST  R7, R0				; R7 is the accumulating sum
0582   008E             	
0583   008E 00 7E       	BRA nextchar
0584   008F             	
0585   008F             quit:	
0586   008F 08 00 00 93 	CALL modify
0587   0091             	
0588   0091 A7 00       	ADD R7					; Add in the final digit
0589   0092 00 4D       	BRA Print_Num			; Print it out in decimal
0590   0093             	
0591   0093             modify:
0592   0093             
0593   0093             	; If R0 = 0-9 subtract 0x30 to form a number 0-9
0594   0093             	; If R0 = A-F subtract 0x37 to form a number 10-15
0595   0093             	
0596   0093 24 00       	LD R0, R4				; Get R0 back from R4
0597   0094 0B 40       	SBI  $40				; Is it bigger than 0x40?
0598   0095 02 98       	BLT  decimal_num		; must be a decimal 0-9
0599   0096 0A 09       	ADI  9                  ; Add 9 to turn R0 into 10 -15
0600   0097 00 9A       	BRA endmodify
0601   0098             	
0602   0098             decimal_num: 
0603   0098             
0604   0098 24 00       	LD R0, R4				; Get R0 back from R4
0605   0099 0B 30       	SBI $30				    ; convert to a decimal number
0606   009A             	
0607   009A             endmodify:
0608   009A             
0609   009A 09 00       	RET
0610   009B             
0611   009B             
0612   009B             ; Get_Hex   33 instructions
0613   009B             	
0614   009B             	
0615   009B             ;------------------------------------Print_Hex------------------------------------
0616   009B             
0617   009B             ;  Prints out a 4 digit hexadecimal number to the terminal according to contents of R0
0618   009B             ;  Leading zeroes are not suppressed
0619   009B             ;  R1 = Heximation Value
0620   009B             ;  R2 = digit count
0621   009B             ;  R4 = temporary storage for accumulator (decimated value)
0622   009B             ;  R6 = temporary store for output character
0623   009B             
0624   009B             ; This is based on the Print_Num routine with modifications to handle A-F characters
0625   009B             
0626   009B             Print_Hex:
0627   009B             
0628   009B 12 00 00 00 		SET R2,   0
0629   009D             				
0630   009D 11 00 10 00 		SET R1,   4096
0631   009F 08 00 00 AC 		CALL   heximate
0632   00A1             		
0633   00A1 11 00 01 00 		SET R1,   256
0634   00A3 08 00 00 AC 		CALL   heximate
0635   00A5             		
0636   00A5 11 00 00 10 		SET R1,   16
0637   00A7 08 00 00 AC 		CALL   heximate
0638   00A9             		
0639   00A9 08 00 00 B9 		CALL printmod		; look at number and print correct character
0640   00AB             		
0641   00AB             		
0642   00AB 09 00       retn:	RET		
0643   00AC             		
0644   00AC             heximate:
0645   00AC             
0646   00AC B1 00       		SUB R1				; Subtract the power of 16
0647   00AD 02 B0       		BLT tempstore		; If it goes negative the decimation is finished
0648   00AE E2 00       		INC R2				; Increment the decimation count
0649   00AF 00 AC       		BRA heximate		; repeat until negative
0650   00B0             		
0651   00B0             tempstore:
0652   00B0             
0653   00B0 34 00       		ST R4, R0			; temporarily store the remainder
0654   00B1 22 00       		LD R0, R2			; get the decimation count from R2
0655   00B2 08 00 00 B9 		CALL printmod       ; look at number and print correct character
0656   00B4             		
0657   00B4 24 00       		LD R0, R4			; get remainder back
0658   00B5 A1 00       		ADD R1				; adds the R1 value to restore sum
0659   00B6 12 00 00 00 		SET R2, 0			; Clear the count
0660   00B8 09 00       		RET
0661   00B9             		
0662   00B9             printmod:					; look at number and print correct character
0663   00B9 0A 30       		ADI $30				; ADD 0x30 to make it a number
0664   00BA 36 00       		ST R6, R0			; Temporary store to R6		
0665   00BB 0B 3A       		SBI $3A				; is it bigger than ascii '9'
0666   00BC 02 C0       		BLT printdec		; output as decimal digit
0667   00BD 0A 41       		ADI $41				; otherwise make it a hex digit
0668   00BE 0C 00       		OUT	
0669   00BF 00 C2       		BRA restore
0670   00C0             		
0671   00C0             printdec:		
0672   00C0 26 00       		LD R0, R6
0673   00C1 0C 00       		OUT
0674   00C2             		
0675   00C2             restore:
0676   00C2 09 00       		RET
0677   00C3             		
0678   00C3             		
0679   00C3             ;		Print_Hex  40 instructions	
0680   00C3             	
0681   00C3             ; ---------------------------HEXDUMP------------------------------------------ 
0682   00C3             
0683   00C3             ; Dump a page of memory to the screen
0684   00C3             ; Address on LHS, followed by 16 words across the screen need about 90 characters wide
0685   00C3             ; Print out 256 words over 16 lines
0686   00C3             
0687   00C3             ; R0 = value to be printed
0688   00C3             ; R11 = pointer to memory starting at 0x0000
0689   00C3             
0690   00C3 19 00 01 00 	SET R9,  $100		; 256 words to dump
0691   00C5 1A 00 00 0A 	SET R10, $0A		; 16 words to a line
0692   00C7 1B 00 00 00 	SET R11, 0			; Begin dump from address 0
0693   00C9             	
0694   00C9             
0695   00C9             nextaddress:	
0696   00C9             	
0697   00C9             	
0698   00C9 2B 00       	LD R0, R11			; Get the address
0699   00CA 08 00 00 9B 	CALL Print_Hex		; print the address
0700   00CC 10 00 00 3E 	SET R0, $3E			; > Cursor
0701   00CE 0C 00       	OUT
0702   00CF 0B 1E       	SBI $1E				; 3E - $1E  = $20  so print two spaces
0703   00D0 0C 00       	OUT
0704   00D1 0C 00       	OUT
0705   00D2             	
0706   00D2             nextword:
0707   00D2             
0708   00D2 4B 00       	LD R0, @R11			; get the next word from memory
0709   00D3 08 00 00 9B 	CALL Print_Hex		; print the mem-word
0710   00D5 10 00 00 20 	SET R0, $20			; a space
0711   00D7 0C 00       	OUT
0712   00D8             	
0713   00D8 EB 00       	INC R11				; increment memory pointer
0714   00D9 DA 00       	DEC R10				; decrement word counter
0715   00DA D9 00       	DEC R9				; decrement page address counter
0716   00DB 2A 00       	LD R0, R10			; get word counter
0717   00DC 01 D2       	BGT nextword
0718   00DD             	
0719   00DD 29 00       	LD R0, R9  			; get page address counter
0720   00DE             	
0721   00DE 04 E4       	BLE nextline
0722   00DF 08 00 00 EF 	CALL crlf
0723   00E1             	
0724   00E1 1A 00 00 16 	SET R10, $16		; reset word counter to 16
0725   00E3             	
0726   00E3 00 C9       	BRA nextaddress		; get address for next line
0727   00E4             
0728   00E4             nextline:
0729   00E4             	
0730   00E4 08 00 00 EF 	CALL crlf			; two blank lines
0731   00E6             	
0732   00E6 00 47       	BRA NEXT
0733   00E7             
0734   00E7             
0735   00E7             ; Hex_Dump 34 instructions
0736   00E7             
0737   00E7             ;--------------------------------------------------------------------------------------------
0738   00E7             
0739   00E7             ;
0740   00E7             ; Send a string to the serial line, HL contains the pointer to the string:
0741   00E7             ;
0742   00E7             puts:
0743   00E7 08 00 00 EC 	CALL putc
0744   00E9 E1 00       	INC R1
0745   00EA 01 E7       	BGT puts
0746   00EB 09 00       	RET
0747   00EC             	
0748   00EC             ;
0749   00EC             ; Send a single character to the serial line (a contains the character):
0750   00EC             ;
0751   00EC             putc:
0752   00EC 41 00       	LD R0, @R1;
0753   00ED 0C 00       	OUT
0754   00EE 09 00       	RET
0755   00EF             	
0756   00EF             crlf:					; Output a CR/LF pair
0757   00EF             
0758   00EF 10 00 02 72 	SET R0, cr			; Load a cr
0759   00F1 0C 00       	OUT
0760   00F2 0B 03       	SBI 3				; Subtract 3 to make a lf
0761   00F3 0C 00       	OUT
0762   00F4 09 00       	RET	
0763   00F5             
0764   00F5             ; Send a CR/LF pair:
0765   00F5             ;
0766   00F5             ; 	crlf:
0767   00F5             ;	SET R1, cr
0768   00F5             ;	call    putc
0769   00F5             ;	SET R1, lf
0770   00F5             ;	call    putc
0771   00F5             ;	ret
0772   00F5             
0773   00F5             
0774   00F5             	
0775   00F5             
0776   0100             .org $0100					; Start of the jump table	
0777   0100             	
0778   0100             ;------------------------------------------------------Jump_Table------------------------------------------
0779   0100             
0780   0100             ;   Symbolic addresses for the primitive routines begin with an underscore so not to be confused 
0781   0100             ;   with assembler mnemonics  eg.  _xor
0782   0100             
0783   0100             
0784   0100             
0785   0100 02 02               .WORD   _space    ; SPACE
0786   0101 03 02               .WORD   _store    ; STORE !
0787   0102 04 02               .WORD   _dup      ; DUP   "
0788   0103 05 02               .WORD   _lit      ; LIT   #      
0789   0104 06 02               .WORD   _swap     ; SWAP  $
0790   0105 07 02               .WORD   _over     ; OVER  %
0791   0106 08 02               .WORD   _and      ; AND   &
0792   0107 0A 02               .WORD   _pop      ; quote ' 		       
0793   0108 0B 02               .WORD   _begin    ; BEGIN (
0794   0109 0C 02               .WORD   _end      ; END   )
0795   010A 0D 02               .WORD   _mul      ; MUL   *
0796   010B 0E 02               .WORD   _add      ; ADD   +           
0797   010C 10 02               .WORD   _push     ; COMMA ,
0798   010D 11 02               .WORD   _sub      ; SUB   -     
0799   010E 13 02               .WORD   _print    ; DOT   .     Print a decimal number
0800   010F 14 02               .WORD   _div      ; DIV   /
0801   0110             		
0802   0110             		; ascii digits 0 to 9 are processed here by jumping to the number routine
0803   0110             		
0804   0110 2B 00       		.WORD   number    ; process numeral '0'
0805   0111 2B 00       		.WORD   number    ; process numeral '1'
0806   0112 2B 00       		.WORD   number    ; process numeral '2'
0807   0113 2B 00       		.WORD   number    ; process numeral '3'
0808   0114 2B 00       		.WORD   number    ; process numeral '4'
0809   0115 2B 00       		.WORD   number    ; process numeral '5'
0810   0116 2B 00       		.WORD   number    ; process numeral '6'
0811   0117 2B 00       		.WORD   number    ; process numeral '7'
0812   0118 2B 00       		.WORD   number    ; process numeral '8'
0813   0119 2B 00       		.WORD   number    ; process numeral '9'
0814   011A             		        
0815   011A             ;-----------------------------------------Jump Table Contd-----------------------------------------
0816   011A             
0817   011A             
0818   011A             
0819   011A                   
0820   011A 15 02               .WORD   _call     ; CALL  :
0821   011B 16 02               .WORD   _ret      ; RET   ;
0822   011C 17 02               .WORD   _less     ; LESS  <
0823   011D 18 02               .WORD   _eq       ; EQ    =		
0824   011E 19 02               .WORD   _greater  ; MORE  >
0825   011F 1A 02               .WORD   _query    ; QUERY ?
0826   0120 1B 02               .WORD   _fetch    ; FETCH @
0827   0121             		
0828   0121             		; Uppercase ALPHA routine are allocated fixed addresses at 32 word intervals
0829   0121             		
0830   0121 20 04       		.WORD   $0420     ; A       
0831   0122 40 04               .WORD   $0440     ; B
0832   0123 60 04               .WORD   $0460     ; C
0833   0124 80 04               .WORD   $0480     ; D
0834   0125 A0 04               .WORD   $04A0     ; E
0835   0126 C0 04               .WORD   $04C0     ; F
0836   0127 E0 04               .WORD   $04E0     ; G
0837   0128 00 05               .WORD   $0500     ; H
0838   0129 20 05               .WORD   $0520     ; I        
0839   012A 40 05               .WORD   $0540     ; J
0840   012B 60 05               .WORD   $0560     ; K
0841   012C 80 05               .WORD   $0580     ; L
0842   012D A0 05               .WORD   $05A0     ; M
0843   012E C0 05               .WORD   $05C0     ; N
0844   012F E0 05               .WORD   $05E0     ; O
0845   0130 00 06               .WORD   $0600     ; P
0846   0131 20 06               .WORD   $0620     ; Q
0847   0132 60 06       		.WORD   $0660     ; R
0848   0133 80 06               .WORD   $0680     ; S
0849   0134 A0 06               .WORD   $06A0     ; T
0850   0135 C0 06               .WORD   $06C0     ; U
0851   0136 E0 06               .WORD   $06E0     ; V
0852   0137 00 07               .WORD   $0700     ; W
0853   0138 20 07               .WORD   $0720     ; X
0854   0139 40 07               .WORD   $0740     ; Y
0855   013A 60 07       		.WORD   $0760     ; Z
0856   013B             
0857   013B             
0858   013B             			
0859   013B 1C 02               .WORD   _in       ; OPEN  [		
0860   013C 1D 02               .WORD   _back     ; BACK  
0861   013D 1E 02               .WORD   _out      ; CLOSE ]        
0862   013E 1F 02               .WORD   _xor      ; XOR   ^      
0863   013F 21 02               .WORD   _under    ; UNDER _		
0864   0140 22 02               .WORD   _tick     ; TICK
0865   0141             		
0866   0141 00 0F               .WORD   $0F00     ; a       
0867   0142 A8 00               .WORD   $00A8     ; b
0868   0143 00 0F               .WORD   $0F00     ; c
0869   0144 00 0F               .WORD   $0F00     ; d
0870   0145 00 0F               .WORD   $0F00     ; e
0871   0146 00 0F               .WORD   $0F00     ; f
0872   0147 00 0F               .WORD   $0F00     ; g
0873   0148 00 0F               .WORD   $0F00     ; h
0874   0149 00 0F               .WORD   $0F00     ; i      
0875   014A B0 00               .WORD   $00B0     ; j
0876   014B 00 0F               .WORD   $0F00     ; k
0877   014C 00 0F               .WORD   $0F00     ; l
0878   014D 00 0F               .WORD   $0F00     ; m
0879   014E 00 0F               .WORD   $0F00     ; n
0880   014F 00 0F               .WORD   $0F00     ; o
0881   0150 00 0F               .WORD   $0F00     ; p
0882   0151 00 0F               .WORD   $0F00     ; q
0883   0152 B8 00               .WORD   $00B8     ; r
0884   0153 00 0F               .WORD   $0F00     ; s
0885   0154 00 0F               .WORD   $0F00     ; t
0886   0155 00 0F               .WORD   $0F00     ; u
0887   0156 00 0F               .WORD   $0F00     ; v
0888   0157 00 0F               .WORD   $0F00     ; w
0889   0158 00 0F               .WORD   $0F00     ; x
0890   0159 00 0F               .WORD   $0F00     ; y   
0891   015A 00 0F               .WORD   $0F00     ; z
0892   015B             		
0893   015B 23 02               .WORD   _tor      ; BRACEL {
0894   015C 24 02               .WORD   _or       ; OR     |   
0895   015D 26 02               .WORD   _fror     ; BRACER }        
0896   015E 27 02               .WORD   _inv      ; INV    ~   
0897   015F 29 02               .WORD   _nop      ; NOP
0898   0160             		
0899   0160             		
0900   0160             		; Jump_Table  96 words
0901   0160                                   
0902   0160             ;--------------------------------------End of Jump Table-------------------------------------
0903   0160             
0904   0160             ;-----------------------------------------Hex_Loader-----------------------------------------
0905   0160             
0906   0160             ; To assemble use : tasm -s -h -c -g0 -t16 hexloader_new_3.asm out.hex
0907   0160             ; Constant definitions
0908   0160             ;
0909   0160             loader_start	.equ	$0160		; hexloader starts here
0910   0160             program_start	.equ	$0300		; hexloader jumps to here when done loading
0911   0160             eos				.equ	$0000		; end of string
0912   0160             
0913   0160             .org	loader_start
0914   0160             
0915   0160             starting_addr:
0916   0160             ; Print a welcome message
0917   0160 11 00 02 2F 	SET R1, hello_msg
0918   0162 08 00 00 E7 	CALL puts
0919   0164 08 00 00 EF 	CALL crlf
0920   0166 10 00 00 3E 	SET R0, 62				; > cursor
0921   0168 0C 00       	OUT						; Print cursor
0922   0169             	
0923   0169             get_colon:	
0924   0169             	; zero checksum
0925   0169 1E 00 00 00 	SET R14, 0				; used to hold checksum
0926   016B             	; get first character 
0927   016B 0D 00       	IN						; getchar
0928   016C 11 00 07 80 	SET R1, $780
0929   016E 41 00       	LD R0, @R1				; get character		
0930   016F 0B 3A       	SBI 58					; ':' char
SIMPL_Suite16_2020_5.asm line 0931: Unused data in MS byte of argument. (1)
0931   0170 05 69       	BNE get_colon
0932   0171             
0933   0171             	; READ LENGTH
0934   0171 08 00 01 DD 	call getbyte
0935   0173             	; value is in R7
0936   0173 27 00       	LD R0, R7
0937   0174 3A 00       	ST R10, R0				; store in R[10]
0938   0175             	
0939   0175             	; READ ADDRESS
0940   0175 08 00 01 EE 	call getword
0941   0177             	; value is in R7
0942   0177 27 00       	LD R0, R7
0943   0178 3B 00       	ST R11, R0				; store in R[11]
0944   0179             	
0945   0179             	; READ RECORD TYPE
0946   0179 08 00 01 DD 	call getbyte
0947   017B             	; value is in R7
0948   017B 27 00       	LD R0, R7
0949   017C 3D 00       	ST R13, R0;				; store in R[13]
0950   017D             	
0951   017D             	; R[10] = length in bytes
0952   017D             	; R[11] = address 
0953   017D             	; R[13] = record type 
0954   017D             	
0955   017D 11 00 00 01 	SET R1, 1				; record type 01
0956   017F 37 00       	ST R7, R0				; store for later
0957   0180 B1 00       	SUB R1					; check if type is 01
SIMPL_Suite16_2020_5.asm line 0958: Unused data in MS byte of argument. (1)
0958   0181 06 B2       	BEQ endload				; record type is 01 (EOF), we are done_msg
0959   0182 27 00       	LD R0, R7				; get value back
SIMPL_Suite16_2020_5.asm line 0960: Unused data in MS byte of argument. (1)
0960   0183 01 A9       	BGT invalid				; check if greater than zero (and not 01)
0961   0184             
0962   0184             read_data:	
0963   0184             	; this is a data byte
0964   0184             msb_part:
0965   0184 08 00 01 DD 	call getbyte
0966   0186             	; value is in R7
0967   0186 27 00       	LD R0, R7				; get byte in R0
0968   0187 A0 00       	ADD R0					; shift
0969   0188 A0 00       	ADD R0
0970   0189 A0 00       	ADD R0
0971   018A A0 00       	ADD R0
0972   018B A0 00       	ADD R0
0973   018C A0 00       	ADD R0
0974   018D A0 00       	ADD R0
0975   018E A0 00       	ADD R0
0976   018F 5B 00       	ST @R11, R0				; store at memory address
0977   0190             	
0978   0190             lsb_part:
0979   0190 08 00 01 DD 	call getbyte
0980   0192             	; value is in R7
0981   0192 4B 00       	LD R0, @R11				; get what is in memory
0982   0193 97 00       	OR R7					; OR lsb into it
0983   0194 5B 00       	ST @R11, R0				; store at memory address
0984   0195             	
0985   0195 EB 00       	INC R11					; next memory address
0986   0196             	
0987   0196             	;decrement 2x
0988   0196 DA 00       	DEC R10					; decrement 
0989   0197 DA 00       	DEC R10					; decrement 
0990   0198             	
0991   0198 2A 00       	LD R0, R10				; get length
SIMPL_Suite16_2020_5.asm line 0992: Unused data in MS byte of argument. (1)
0992   0199 01 84       	BGT read_data			; 
0993   019A             	
0994   019A             	; GET LAST BYTE
0995   019A 08 00 01 DD 	call getbyte			; get checksum byte
0996   019C             	
0997   019C             	; CHECK CHECKSUM
0998   019C 2E 00       	LD R0, R14				; get checksum byte
0999   019D 11 00 00 FF 	SET R1, $00FF
1000   019F 81 00       	AND R1
SIMPL_Suite16_2020_5.asm line 1001: Unused data in MS byte of argument. (1)
1001   01A0 05 C5       	BNE checksum_error
1002   01A1             	
1003   01A1 08 00 00 EF 	call crlf
1004   01A3 10 00 00 3E 	SET R0, 62				; > cursor
1005   01A5 0C 00       	OUT						; Print cursor
SIMPL_Suite16_2020_5.asm line 1006: Unused data in MS byte of argument. (1)
1006   01A6 00 69       	BRA get_colon
1007   01A7             	
1008   01A7 07 00 01 CE 	JMP loop				 ; TODO check
1009   01A9             	
1010   01A9             invalid:
1011   01A9 08 00 00 EF 	call crlf
1012   01AB 11 00 02 51 	SET R1, invalid_msg
1013   01AD 08 00 00 E7 	call puts
1014   01AF 08 00 00 EF 	call crlf
SIMPL_Suite16_2020_5.asm line 1015: Unused data in MS byte of argument. (1)
1015   01B1 00 60       	BRA starting_addr
1016   01B2             	
1017   01B2             endload:
1018   01B2 08 00 01 DD 	call getbyte			; get last checksum byte
1019   01B4             
1020   01B4 2E 00       	LD R0, R14				; get checksum byte
1021   01B5 11 00 00 FF 	SET R1, $00FF
1022   01B7 81 00       	AND R1
SIMPL_Suite16_2020_5.asm line 1023: Unused data in MS byte of argument. (1)
1023   01B8 05 C5       	BNE checksum_error
1024   01B9 08 00 00 EF 	call crlf
1025   01BB 11 00 02 65 	SET R1, done_msg
1026   01BD 08 00 00 E7 	call puts
1027   01BF 08 00 00 EF 	call crlf
1028   01C1 08 00 00 EF 	call crlf
1029   01C3             
1030   01C3             	; jump to fixed memory location (loaded program)
1031   01C3             	; loader program has to start at location "program_start" for now
1032   01C3 07 00 03 00 	JMP program_start
1033   01C5             	
1034   01C5             checksum_error:
1035   01C5 08 00 00 EF 	call crlf
1036   01C7 11 00 02 42 	SET R1, error_msg
1037   01C9 08 00 00 E7 	call puts
1038   01CB 08 00 00 EF 	call crlf
SIMPL_Suite16_2020_5.asm line 1039: Unused data in MS byte of argument. (1)
1039   01CD 00 60       	BRA starting_addr
1040   01CE             	
1041   01CE             	; program should never get here !!!
1042   01CE             loop:
SIMPL_Suite16_2020_5.asm line 1043: Unused data in MS byte of argument. (1)
1043   01CE 00 CE       	BRA loop
1044   01CF             
1045   01CF             getnibble:
1046   01CF 0D 00       	IN				; read char from serial in
1047   01D0 11 00 07 80 	SET R1, $780
1048   01D2 41 00       	LD R0, @R1		; get character
1049   01D3 0B 30       	SBI $30		
1050   01D4 32 00       	ST R2, R0		; save temporary
1051   01D5 0B 0A       	SBI 10
SIMPL_Suite16_2020_5.asm line 1052: Unused data in MS byte of argument. (1)
1052   01D6 02 DA       	BLT decimal
1053   01D7 22 00       	LD R0, R2		; restore value
1054   01D8 0B 07       	SBI 7
SIMPL_Suite16_2020_5.asm line 1055: Unused data in MS byte of argument. (1)
1055   01D9 00 DB       	BRA hexadecimal
1056   01DA             decimal:	
1057   01DA 22 00       	LD R0, R2		; restore value
1058   01DB             hexadecimal:	
1059   01DB 37 00       	ST R7, R0		; value is stored in R7
1060   01DC 09 00       	RET
1061   01DD             	
1062   01DD             ;
1063   01DD             ;
1064   01DD             ;
1065   01DD             getbyte:
1066   01DD 08 00 01 CF 	call getnibble
1067   01DF 27 00       	LD R0, R7
1068   01E0 A0 00       	ADD R0
1069   01E1 A0 00       	ADD R0
1070   01E2 A0 00       	ADD R0
1071   01E3 A0 00       	ADD R0
1072   01E4 38 00       	ST R8, R0		; temporary store msb 
1073   01E5 08 00 01 CF 	call getnibble
1074   01E7 27 00       	LD R0, R7		; get back lsb
1075   01E8 98 00       	OR R8			; create word value
1076   01E9 37 00       	ST R7, R0		; value is stored in R7
1077   01EA             	
1078   01EA             	; store byte for checksum
1079   01EA 2E 00       	LD R0, R14		; load checksum
1080   01EB A7 00       	ADD R7			; add byte to checksum
1081   01EC 3E 00       	ST R14, R0
1082   01ED             	
1083   01ED 09 00       	RET
1084   01EE             
1085   01EE             getword:
1086   01EE 08 00 01 DD 	call getbyte
1087   01F0 27 00       	LD R0, R7
1088   01F1 A0 00       	ADD R0
1089   01F2 A0 00       	ADD R0
1090   01F3 A0 00       	ADD R0
1091   01F4 A0 00       	ADD R0
1092   01F5 A0 00       	ADD R0
1093   01F6 A0 00       	ADD R0
1094   01F7 A0 00       	ADD R0
1095   01F8 A0 00       	ADD R0
1096   01F9 39 00       	ST R9, R0		; CHECK IF NEEDED
1097   01FA 08 00 01 DD 	call getbyte
1098   01FC 27 00       	LD R0, R7		; get back lsb ???
1099   01FD 99 00       	OR R9
1100   01FE 37 00       	ST R7, R0
1101   01FF 09 00       	RET
1102   0200             	
1103   0200             ;------------------------------------------Primitive Routines------------------------------------
1104   0200             
1105   0200             .org $0200	
1106   0200             
1107   0200             ; All primitive address labels begin with an underscore to avaid confusion with mnemonics
1108   0200             ; The following 34 primitives are single ascii symbols such as $ % & * ( ) etc
1109   0200             ; _next is a local page trampoline to NEXT
1110   0200             
1111   0200             _next:
1112   0200 07 00 00 47 	JMP NEXT
1113   0202             
1114   0202             
1115   0202             _space:
SIMPL_Suite16_2020_5.asm line 1116: Unused data in MS byte of argument. (2)
1116   0202 00 00       	BRA _next
1117   0203             
1118   0203             _store:
SIMPL_Suite16_2020_5.asm line 1119: Unused data in MS byte of argument. (2)
1119   0203 00 00       	BRA _next
1120   0204             
1121   0204             _dup:
SIMPL_Suite16_2020_5.asm line 1122: Unused data in MS byte of argument. (2)
1122   0204 00 00       	BRA _next
1123   0205             
1124   0205             _lit:
SIMPL_Suite16_2020_5.asm line 1125: Unused data in MS byte of argument. (2)
1125   0205 00 00       	BRA _next
1126   0206             
1127   0206             _swap:
SIMPL_Suite16_2020_5.asm line 1128: Unused data in MS byte of argument. (2)
1128   0206 00 00           BRA _next
1129   0207             
1130   0207             _over:
SIMPL_Suite16_2020_5.asm line 1131: Unused data in MS byte of argument. (2)
1131   0207 00 00           BRA _next
1132   0208             
1133   0208             _and:
1134   0208 81 00       	AND R1		; AND
SIMPL_Suite16_2020_5.asm line 1135: Unused data in MS byte of argument. (2)
1135   0209 00 00           BRA _next
1136   020A             
1137   020A             _pop:
SIMPL_Suite16_2020_5.asm line 1138: Unused data in MS byte of argument. (2)
1138   020A 00 00           BRA _next
1139   020B             
1140   020B             _begin:
SIMPL_Suite16_2020_5.asm line 1141: Unused data in MS byte of argument. (2)
1141   020B 00 00           BRA _next
1142   020C             
1143   020C             _end:
SIMPL_Suite16_2020_5.asm line 1144: Unused data in MS byte of argument. (2)
1144   020C 00 00           BRA _next
1145   020D             
1146   020D             _mul:
SIMPL_Suite16_2020_5.asm line 1147: Unused data in MS byte of argument. (2)
1147   020D 00 00           BRA _next
1148   020E             
1149   020E             _add:
1150   020E A1 00       	ADD R1    ; ADD
SIMPL_Suite16_2020_5.asm line 1151: Unused data in MS byte of argument. (2)
1151   020F 00 00           BRA _next
1152   0210             
1153   0210             _push:
SIMPL_Suite16_2020_5.asm line 1154: Unused data in MS byte of argument. (2)
1154   0210 00 00           BRA _next
1155   0211             
1156   0211             _sub:
1157   0211 B1 00       	SUB R1    ; SUB
SIMPL_Suite16_2020_5.asm line 1158: Unused data in MS byte of argument. (2)
1158   0212 00 00           BRA _next
1159   0213             
1160   0213             _print:
SIMPL_Suite16_2020_5.asm line 1161: Unused data in MS byte of argument. (2)
1161   0213 00 00           BRA _next
1162   0214             
1163   0214             _div:
SIMPL_Suite16_2020_5.asm line 1164: Unused data in MS byte of argument. (2)
1164   0214 00 00           BRA _next
1165   0215             
1166   0215             _call:
SIMPL_Suite16_2020_5.asm line 1167: Unused data in MS byte of argument. (2)
1167   0215 00 00           BRA _next
1168   0216             
1169   0216             _ret:
SIMPL_Suite16_2020_5.asm line 1170: Unused data in MS byte of argument. (2)
1170   0216 00 00           BRA _next
1171   0217             
1172   0217             _less:
SIMPL_Suite16_2020_5.asm line 1173: Unused data in MS byte of argument. (2)
1173   0217 00 00           BRA _next
1174   0218             
1175   0218             _eq:
SIMPL_Suite16_2020_5.asm line 1176: Unused data in MS byte of argument. (2)
1176   0218 00 00           BRA _next
1177   0219             
1178   0219             _greater:
SIMPL_Suite16_2020_5.asm line 1179: Unused data in MS byte of argument. (2)
1179   0219 00 00           BRA _next
1180   021A             
1181   021A             _query:
SIMPL_Suite16_2020_5.asm line 1182: Unused data in MS byte of argument. (2)
1182   021A 00 00           BRA _next
1183   021B             
1184   021B             _fetch:
SIMPL_Suite16_2020_5.asm line 1185: Unused data in MS byte of argument. (2)
1185   021B 00 00           BRA _next
1186   021C             
1187   021C             _in:
SIMPL_Suite16_2020_5.asm line 1188: Unused data in MS byte of argument. (2)
1188   021C 00 00           BRA _next
1189   021D             
1190   021D             _back:
SIMPL_Suite16_2020_5.asm line 1191: Unused data in MS byte of argument. (2)
1191   021D 00 00           BRA _next
1192   021E             
1193   021E             _out:
SIMPL_Suite16_2020_5.asm line 1194: Unused data in MS byte of argument. (2)
1194   021E 00 00           BRA _next
1195   021F             
1196   021F             _xor:
1197   021F F1 00       	XOR R1		; XOR
SIMPL_Suite16_2020_5.asm line 1198: Unused data in MS byte of argument. (2)
1198   0220 00 00           BRA _next
1199   0221             
1200   0221             _under:
SIMPL_Suite16_2020_5.asm line 1201: Unused data in MS byte of argument. (2)
1201   0221 00 00           BRA _next
1202   0222             
1203   0222             _tick:
SIMPL_Suite16_2020_5.asm line 1204: Unused data in MS byte of argument. (2)
1204   0222 00 00           BRA _next
1205   0223             
1206   0223             _tor:
SIMPL_Suite16_2020_5.asm line 1207: Unused data in MS byte of argument. (2)
1207   0223 00 00           BRA _next
1208   0224             
1209   0224             _or:
1210   0224 91 00       	OR R1		; OR
SIMPL_Suite16_2020_5.asm line 1211: Unused data in MS byte of argument. (2)
1211   0225 00 00           BRA _next
1212   0226             
1213   0226             _fror:
SIMPL_Suite16_2020_5.asm line 1214: Unused data in MS byte of argument. (2)
1214   0226 00 00           BRA _next
1215   0227             
1216   0227             _inv:
1217   0227 C0 00       	INV  R0		; INV
SIMPL_Suite16_2020_5.asm line 1218: Unused data in MS byte of argument. (2)
1218   0228 00 00           BRA _next
1219   0229             
1220   0229             _nop:
1221   0229 0F 00       	NOP
SIMPL_Suite16_2020_5.asm line 1222: Unused data in MS byte of argument. (2)
1222   022A 00 00           BRA _next
1223   022B             
1224   022B             	
1225   022B             	;---------------------------------------Arithmetic & Logic-----------------------------------
1226   022B             
1227   022B             _inc:
1228   022B E0 00             INC  R0   ; INC
1229   022C 00 47             BRA NEXT
1230   022D             _dec:	  
1231   022D D0 00             DEC  R0   ; DEC
1232   022E 00 47             BRA NEXT
1233   022F             	  
1234   022F             	; Arithmetic and logic operations  4 instructions  
1235   022F             ;----------------------------------------------------------------------------------------------------------	
1236   022F             
1237   022F             
1238   022F             	
1239   022F             ; Message definitions
1240   022F             ;
1241   022F             .MSFIRST
1242   022F 00 53 00 75 hello_msg		.WORD	"Suite16 Hex Loader", eos
1242   0231 00 69 00 74 
1242   0233 00 65 00 31 
1242   0235 00 36 00 20 
1242   0237 00 48 00 65 
1242   0239 00 78 00 20 
1242   023B 00 4C 00 6F 
1242   023D 00 61 00 64 
1242   023F 00 65 00 72 
1242   0241 00 00 
1243   0242 00 43 00 68 error_msg		.WORD	"Checksum error", eos
1243   0244 00 65 00 63 
1243   0246 00 6B 00 73 
1243   0248 00 75 00 6D 
1243   024A 00 20 00 65 
1243   024C 00 72 00 72 
1243   024E 00 6F 00 72 
1243   0250 00 00 
1244   0251 00 49 00 6E invalid_msg		.WORD	"Invalid record type", eos
1244   0253 00 76 00 61 
1244   0255 00 6C 00 69 
1244   0257 00 64 00 20 
1244   0259 00 72 00 65 
1244   025B 00 63 00 6F 
1244   025D 00 72 00 64 
1244   025F 00 20 00 74 
1244   0261 00 79 00 70 
1244   0263 00 65 00 00 
1245   0265 00 44 00 6F done_msg		.WORD	"Done loading", eos
1245   0267 00 6E 00 65 
1245   0269 00 20 00 6C 
1245   026B 00 6F 00 61 
1245   026D 00 64 00 69 
1245   026F 00 6E 00 67 
1245   0271 00 00 
1246   0272             
1247   0272             ;
1248   0272             ; 
1249   0272             ;
1250   0272             	
1251   0272             .MSFIRST
1252   0272 00 0D       cr				.WORD $0d	; carriage return
1253   0273 00 0A       lf				.WORD $0a	; line feed
1254   0274 00 20       space			.WORD $20	; space
1255   0275             .end	
ADDR  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
-----------------------------------------------------
0000  00 72 18 00 07 80 E8 00 48 00 34 00 0B 0D 06 25
0010  24 00 0B 0A 06 25 24 00 0B 20 04 24 24 00 0B 7F
0020  03 24 24 00 0B 3E 05 21 08 00 00 72 0B 50 A0 00
0030  A0 00 A0 00 A0 00 A0 00 A8 00 32 00 24 00 52 00
0040  00 24 E8 00 24 00 58 00 00 72 10 00 00 80 58 00
0050  18 00 07 80 00 47 17 00 00 00 18 00 07 80 48 00
0060  34 00 E8 00 48 00 0B 30 02 42 0B 0A 03 42 24 00
0070  0B 30 A7 00 35 00 A5 00 A0 00 A0 00 A5 00 A5 00
0080  37 00 00 2F 24 00 A7 00 32 00 17 00 00 00 E8 00
0090  48 00 0A E0 33 00 43 00 00 E0 12 00 00 00 11 00
00A0  27 10 08 00 00 65 11 00 03 E8 08 00 00 65 11 00
00B0  00 64 08 00 00 65 11 00 00 0A 08 00 00 65 0A 30
00C0  0C 00 B4 00 08 00 00 EF 00 47 B1 00 02 69 E2 00
00D0  00 65 34 00 22 00 0A 30 0C 00 24 00 A1 00 12 00
00E0  00 00 09 00 0D 00 11 00 07 80 41 00 0C 00 E1 00
00F0  01 75 00 03 11 00 07 80 17 00 00 00 41 00 34 00
0100  E1 00 41 00 0B 30 02 8F 0B 17 03 8F 08 00 00 93
0110  A7 00 A0 00 A0 00 A0 00 A0 00 37 00 00 7E 08 00
0120  00 93 A7 00 00 4D 24 00 0B 40 02 98 0A 09 00 9A
0130  24 00 0B 30 09 00 12 00 00 00 11 00 10 00 08 00
0140  00 AC 11 00 01 00 08 00 00 AC 11 00 00 10 08 00
0150  00 AC 08 00 00 B9 09 00 B1 00 02 B0 E2 00 00 AC
0160  34 00 22 00 08 00 00 B9 24 00 A1 00 12 00 00 00
0170  09 00 0A 30 36 00 0B 3A 02 C0 0A 41 0C 00 00 C2
0180  26 00 0C 00 09 00 19 00 01 00 1A 00 00 0A 1B 00
0190  00 00 2B 00 08 00 00 9B 10 00 00 3E 0C 00 0B 1E
01A0  0C 00 0C 00 4B 00 08 00 00 9B 10 00 00 20 0C 00
01B0  EB 00 DA 00 D9 00 2A 00 01 D2 29 00 04 E4 08 00
01C0  00 EF 1A 00 00 16 00 C9 08 00 00 EF 00 47 08 00
01D0  00 EC E1 00 01 E7 09 00 41 00 0C 00 09 00 10 00
01E0  02 72 0C 00 0B 03 0C 00 09 00 00 00 00 00 00 00
01F0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0200  02 02 03 02 04 02 05 02 06 02 07 02 08 02 0A 02
0210  0B 02 0C 02 0D 02 0E 02 10 02 11 02 13 02 14 02
0220  2B 00 2B 00 2B 00 2B 00 2B 00 2B 00 2B 00 2B 00
0230  2B 00 2B 00 15 02 16 02 17 02 18 02 19 02 1A 02
0240  1B 02 20 04 40 04 60 04 80 04 A0 04 C0 04 E0 04
0250  00 05 20 05 40 05 60 05 80 05 A0 05 C0 05 E0 05
0260  00 06 20 06 60 06 80 06 A0 06 C0 06 E0 06 00 07
0270  20 07 40 07 60 07 1C 02 1D 02 1E 02 1F 02 21 02
0280  22 02 00 0F A8 00 00 0F 00 0F 00 0F 00 0F 00 0F
0290  00 0F 00 0F B0 00 00 0F 00 0F 00 0F 00 0F 00 0F
02A0  00 0F 00 0F B8 00 00 0F 00 0F 00 0F 00 0F 00 0F
02B0  00 0F 00 0F 00 0F 23 02 24 02 26 02 27 02 29 02
02C0  11 00 02 2F 08 00 00 E7 08 00 00 EF 10 00 00 3E
02D0  0C 00 1E 00 00 00 0D 00 11 00 07 80 41 00 0B 3A
02E0  05 69 08 00 01 DD 27 00 3A 00 08 00 01 EE 27 00
02F0  3B 00 08 00 01 DD 27 00 3D 00 11 00 00 01 37 00
0300  B1 00 06 B2 27 00 01 A9 08 00 01 DD 27 00 A0 00
0310  A0 00 A0 00 A0 00 A0 00 A0 00 A0 00 A0 00 5B 00
0320  08 00 01 DD 4B 00 97 00 5B 00 EB 00 DA 00 DA 00
0330  2A 00 01 84 08 00 01 DD 2E 00 11 00 00 FF 81 00
0340  05 C5 08 00 00 EF 10 00 00 3E 0C 00 00 69 07 00
0350  01 CE 08 00 00 EF 11 00 02 51 08 00 00 E7 08 00
0360  00 EF 00 60 08 00 01 DD 2E 00 11 00 00 FF 81 00
0370  05 C5 08 00 00 EF 11 00 02 65 08 00 00 E7 08 00
0380  00 EF 08 00 00 EF 07 00 03 00 08 00 00 EF 11 00
0390  02 42 08 00 00 E7 08 00 00 EF 00 60 00 CE 0D 00
03A0  11 00 07 80 41 00 0B 30 32 00 0B 0A 02 DA 22 00
03B0  0B 07 00 DB 22 00 37 00 09 00 08 00 01 CF 27 00
03C0  A0 00 A0 00 A0 00 A0 00 38 00 08 00 01 CF 27 00
03D0  98 00 37 00 2E 00 A7 00 3E 00 09 00 08 00 01 DD
03E0  27 00 A0 00 A0 00 A0 00 A0 00 A0 00 A0 00 A0 00
03F0  A0 00 39 00 08 00 01 DD 27 00 99 00 37 00 09 00
0400  07 00 00 47 00 00 00 00 00 00 00 00 00 00 00 00
0410  81 00 00 00 00 00 00 00 00 00 00 00 A1 00 00 00
0420  00 00 B1 00 00 00 00 00 00 00 00 00 00 00 00 00
0430  00 00 00 00 00 00 00 00 00 00 00 00 00 00 F1 00
0440  00 00 00 00 00 00 00 00 91 00 00 00 00 00 C0 00
0450  00 00 0F 00 00 00 E0 00 00 47 D0 00 00 47 00 53
0460  00 75 00 69 00 74 00 65 00 31 00 36 00 20 00 48
0470  00 65 00 78 00 20 00 4C 00 6F 00 61 00 64 00 65
0480  00 72 00 00 00 43 00 68 00 65 00 63 00 6B 00 73
0490  00 75 00 6D 00 20 00 65 00 72 00 72 00 6F 00 72
04A0  00 00 00 49 00 6E 00 76 00 61 00 6C 00 69 00 64
04B0  00 20 00 72 00 65 00 63 00 6F 00 72 00 64 00 20
04C0  00 74 00 79 00 70 00 65 00 00 00 44 00 6F 00 6E
04D0  00 65 00 20 00 6C 00 6F 00 61 00 64 00 69 00 6E
04E0  00 67 00 00 00 0D 00 0A 00 20 00 00 00 00 00 00


tasm: Number of errors = 46
